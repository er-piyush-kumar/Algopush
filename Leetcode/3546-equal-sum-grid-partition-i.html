<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LeetCode 3546 | Equal Sum Grid Partition I</title>
  <meta name="description" content="LeetCode 3546: Learn efficient methods to partition grids into equal sums. Detailed analysis with matrix traversal techniques and Python/Java/C++ code.">
  <meta name="keywords" content="LeetCode 3546, Grid Partition, Matrix Algorithms, Array Manipulation, Equal Sum Partition, Competitive Programming, leetcode, leetcode problem of the day, leetcode contest question, leetcode easy question, leetcode medium question,leetcode daily question, Leetcode company dsa problem">
  <meta name="author" content="Algopush" />
  <link rel="canonical" href="https://algopush.com/Leetcode/3546-equal-sum-grid-partition-i.html">

  <!-- Favicon -->
  <link rel="icon" href="../components/favicon.png" type="image/x-icon">
  <link rel="apple-touch-icon" href="../components/favicon.png">

  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="LeetCode 3546: Equal Sum Grid Partition I">
  <meta property="og:description" content="Master grid partitioning techniques for equal sums with optimal time complexity. Complete guide with mathematical proofs and multi-language implementations.">
  <meta property="og:image" content="https://algopush.com/Leetcode/Images/3546.png">
  <meta property="og:url" content="https://algopush.com/Leetcode/3546-equal-sum-grid-partition-i.html">
  <meta property="og:type" content="article">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="LeetCode 3546: Equal Sum Grid Partition I">
  <meta name="twitter:description" content="Optimal solution for grid partitioning with horizontal/vertical cuts. Code examples in Python, Java, and C++.">
  <meta name="twitter:image" content="https://algopush.com/Leetcode/Images/3546.png">

  <!-- Structured Data for SEO -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Equal Sum Grid Partition I",
      "url": "https://algopush.com/Leetcode/3546-equal-sum-grid-partition-i.html",
      "image": "https://algopush.com/Leetcode/Images/3546.png",
      "author": {
        "@type": "Organization",
        "name": "Algopush",
        "url": "https://algopush.com"
      },
      "datePublished": "2025-05-15",
      "dateModified": "2025-05-15",
      "publisher": {
        "@type": "Organization",
        "name": "Algopush",
        "logo": {
          "@type": "ImageObject",
          "url": "https://algopush.com/components/logo.png"
        }
      }
    }
  </script>

  <style>
    :root {
      --primary-color: #102c41;
      --secondary-color: #196391;
      --accent-color: #102c41;
      --meta-color: #db5305;
      --light-bg: #f5f9fc;
      --highlight-color: #f5f9fc;
      --text-color: black;
      --light-text: #7f8c8d;
      --border-radius: 6px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
      --callout-tip: #e8f8f5;
      --callout-note: #eaf2f8;
      --callout-warning: #fef5e7;
      --callout-danger: #ffebee;
      --callout-tip-border: #1abc9c;
      --callout-note-border: #3498db;
      --callout-warning-border: #f39c12;
      --callout-danger-border: #f44336;
    }

    /* Base Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background-color: var(--light-bg);
      color: var(--text-color);
      line-height: 1.7;
      font-size: 1.05rem;
    }

    /* Main Content Container */
    main {
      max-width: 920px;
      margin: 2rem auto;
      padding: 2rem;
      background: #fff;
      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius);
    }

    /* Problem Visualization Image */
    .problem-visual {
      max-width: 100%;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    .problem-visual img {
      width: 100%;
      height: auto;
      display: block;
    }

    /* Typography */
    h1,
    h2,
    h3,
    h4 {
      color: var(--primary-color);
      font-weight: 600;
      margin-top: 1.8rem;
      margin-bottom: 1rem;
      line-height: 1.3;
    }

    h1 {
      font-size: 2rem;
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 0.5rem;
    }

    h2 {
      font-size: 1.6rem;
      border-left: 4px solid var(--accent-color);
      padding-left: 0.8rem;
    }

    h3 {
      font-size: 1.3rem;
      color: var(--secondary-color);
    }

    a {
      color: var(--accent-color);
      text-decoration: none;
      transition: var(--transition);
    }

    a:hover {
      color: var(--primary-color);
      text-decoration: underline;
    }

    hr {
      border: 0;
      height: 1px;
      background: #ddd;
    }

    /* Code Blocks */
    pre {
      background: #f8f9fa;
      padding: 1.2rem;
      border-radius: var(--border-radius);
      overflow-x: auto;
      border-left: 4px solid var(--accent-color);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    code {
      font-family: monospace;
      color: #2c3e50;
    }

    .highlight {
      background: var(--highlight-color);
      padding: 1rem;
      border-radius: var(--border-radius);
      margin: 1.5rem 0;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    th,
    td {
      padding: 0.8rem;
      text-align: center;
      border: 1px solid #ddd;
    }

    th {
      background-color: var(--primary-color);
      color: white;
      font-weight: 500;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    /* Code Container */
    .code-container {
      position: relative;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    .code-header {
      background: var(--primary-color);
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: white;
    }

    .code-filename {
      font-weight: 600;
    }

    .code-copy {
      background: white;
      color: var(--primary-color);
      border: none;
      padding: 0.25rem 0.75rem;
      border-radius: 3px;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 500;
    }

    .code-copy:hover {
      background: var(--highlight-color);
    }

    /* Code Syntax Highlighting */
    .code-token-keyword {
      color: #d73a49;
    }

    .code-token-function {
      color: #6f42c1;
    }

    .code-token-comment {
      color: #6a737d;
      font-style: italic;
    }

    .code-token-string {
      color: #032f62;
    }

    .code-token-number {
      color: #005cc5;
    }

    /* Tabs */
    .code-tabs {
      margin: 2rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    .tab-buttons {
      display: flex;
      background: #eaecee;
      border-bottom: 1px solid #ddd;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .tab-button {
      padding: 0.7rem 1.2rem;
      background: transparent;
      border: none;
      cursor: pointer;
      font-weight: 500;
      color: var(--text-color);
      transition: var(--transition);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .tab-button.active {
      background: var(--primary-color);
      color: white;
    }

    .tab-button:hover:not(.active) {
      background: #d5dbdb;
    }

    .tab-content {
      display: none;
      background: white;
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    /* FAQ Section */
    .faq-section {
      margin: 2rem 0;
    }

    .faq-section details {
      margin: 0.8rem 0;
      padding: 0.1rem;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      background: white;
      transition: var(--transition);
    }

    .faq-section details[open] {
      border-color: var(--accent-color);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      background: #f9f9f9;
    }

    .faq-section summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--primary-color);
      padding: 0.8rem;
      outline: none;
      transition: var(--transition);
    }

    .faq-section summary:hover {
      color: var(--accent-color);
      background: #f5f5f5;
    }

    .faq-section p {
      margin-top: 1rem;
      padding: 0 1rem 1rem;
    }

    /* Breadcrumb Navigation */
    .breadcrumb {
      padding: 0.8rem 1rem;
      background: linear-gradient(to right, #f5f5f5, white);
      border-radius: var(--border-radius);
      margin-bottom: 2rem;
      font-size: 0.9rem;
    }

    .breadcrumb a {
      color: var(--secondary-color);
    }

    .breadcrumb a:hover {
      text-decoration: underline;
    }

    /* Problem Metadata */
    .problem-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin: 1.5rem 0;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: var(--border-radius);
    }

    .meta-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .meta-item .label {
      font-weight: 600;
      color: var(--meta-color);
    }

    /* Callout Boxes */
    .callout {
      padding: 1rem 1.5rem;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      border-left: 4px solid;
    }

    .callout.tip {
      background-color: var(--callout-tip);
      border-color: var(--callout-tip-border);
    }

    .callout.note {
      background-color: var(--callout-note);
      border-color: var(--callout-note-border);
    }

    .callout.warning {
      background-color: var(--callout-warning);
      border-color: var(--callout-warning-border);
    }

    .callout.danger {
      background-color: var(--callout-danger);
      border-color: var(--callout-danger-border);
    }

    .callout strong {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      main {
        margin: 1rem;
        padding: 1.5rem;
      }

      h1 {
        font-size: 1.7rem;
      }

      h2 {
        font-size: 1.4rem;
      }

      .problem-meta {
        flex-direction: column;
      }

      table {
        display: block;
        overflow-x: auto;
      }
    }

    @media (max-width: 480px) {
      main {
        padding: 1rem;
      }

      h1 {
        font-size: 1.5rem;
      }

      h2 {
        font-size: 1.2rem;
      }

      pre {
        padding: 0.8rem;
        font-size: 0.85rem;
      }

      .tab-button {
        padding: 0.6rem;
        font-size: 0.9rem;
      }

      .code-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .code-copy {
        margin-top: 0.5rem;
      }
    }
  </style>
</head>

<body>
  <div id="header"></div>

  <main>
    <div class="breadcrumb">
      <a href="https://algopush.com">Home</a> &gt;
      <a href="https://algopush.com/Leetcode/leetcode.html">LeetCode</a> &gt;
      <span>3546. Equal Sum Grid Partition I</span>
    </div>

    <div class="problem-visual">
      <img src="https://algopush.com/Leetcode/Images/3546.png" alt="Grid partition visualization" loading="lazy">
    </div>

    <h1>3546: Equal Sum Grid Partition I</h1>

    <div class="problem-meta">
      <div class="meta-item">
        <span class="label">Difficulty:</span>
        <span class="value">Medium</span>
      </div>
      <div class="meta-item">
        <span class="label">Topics:</span>
        <span class="value">Matrix, Prefix Sum, Array Manipulation</span>
      </div>
      <div class="meta-item">
        <span class="label">Companies:</span>
        <span class="value">Microsoft, Amazon, Oracle</span>
      </div>
    </div>

    <div class="callout tip">
      <strong>Key Insight:</strong> The solution requires calculating prefix sums efficiently and understanding parity conditions for equal partitioning.
    </div>

    <h2>Problem Statement</h2>
    <p>Given an m x n matrix of positive integers, determine if a single horizontal or vertical cut can split the grid into two non-empty parts with equal sums.</p>

    <h3>Example 1</h3>
    <pre><code>Input: grid = [[1,4],[2,3]]
Output: true
Explanation: Horizontal cut after first row creates two parts with sum 5 each</code></pre>

    <h3>Example 2</h3>
    <pre><code>Input: grid = [[1,3],[2,4]]
Output: false
Explanation: No valid cut exists</code></pre>

    <div class="callout note">
      <strong>Problem Link:</strong>
      <a href="https://leetcode.com/problems/equal-sum-grid-partition-i/" target="_blank" rel="noopener noreferrer">
        View on LeetCode ↗
      </a>
    </div>

    <hr />

    <h2>Approach 1: Prefix Sum Analysis</h2>
    <p>Calculate total sum and check possible cuts using row/column prefix sums.</p>

    <h3>Algorithm Steps</h3>
    <ol>
      <li>Calculate total sum of all elements</li>
      <li>Return false if total is odd</li>
      <li>Check horizontal cuts using row prefix sums</li>
      <li>Check vertical cuts using column prefix sums</li>
    </ol>

    <h3>Complexity Analysis</h3>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>O(m*n)</td>
          <td>O(max(m,n))</td>
        </tr>
      </tbody>
    </table>

    <div class="code-container">
      <div class="code-header">
        <span class="code-filename">Optimal Solution</span>
        <button class="code-copy">Copy Code</button>
      </div>
      <div class="code-tabs">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="cpp-sol">C++</button>
          <button class="tab-button" data-tab="java-sol">Java</button>
          <button class="tab-button" data-tab="python-sol">Python</button>
        </div>

        <!-- C++ Code -->
        <div class="tab-content active" id="cpp-sol-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">bool</span> <span class="code-token-function">canSplit</span>(vector&lt;vector&lt;<span class="code-token-keyword">int</span>&gt;&gt;& grid) {
        <span class="code-token-keyword">int</span> total = 0;
        <span class="code-token-keyword">for</span>(auto& row : grid) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> num : row) {
                total += num;
            }
        }
        
        <span class="code-token-keyword">if</span>(total % 2 != 0) <span class="code-token-keyword">return</span> false;
        <span class="code-token-keyword">int</span> target = total / 2;
        
        <span class="code-token-keyword">int</span> rowSum = 0;
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> i = 0; i < grid.<span class="code-token-function">size</span>(); ++i) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> num : grid[i]) {
                rowSum += num;
            }
            <span class="code-token-keyword">if</span>(rowSum == target && i != grid.<span class="code-token-function">size</span>()-1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">int</span> n = grid[0].<span class="code-token-function">size</span>();
        vector&lt;<span class="code-token-keyword">int</span>&gt; <span class="code-token-function">colSums</span>(n, 0);
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> j = 0; j < n; ++j) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> i = 0; i < grid.<span class="code-token-function">size</span>(); ++i) {
                colSums[j] += grid[i][j];
            }
        }
        
        <span class="code-token-keyword">int</span> colPrefix = 0;
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> j = 0; j < n; ++j) {
            colPrefix += colSums[j];
            <span class="code-token-keyword">if</span>(colPrefix == target && j != n-1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">return</span> false;
    }
};</code></pre>
        </div>

        <!-- Java Code -->
        <div class="tab-content" id="java-sol-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">boolean</span> <span class="code-token-function">canSplit</span>(<span class="code-token-keyword">int</span>[][] grid) {
        <span class="code-token-keyword">int</span> total = 0;
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span>[] row : grid) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> num : row) {
                total += num;
            }
        }
        
        <span class="code-token-keyword">if</span>(total % 2 != 0) <span class="code-token-keyword">return</span> false;
        <span class="code-token-keyword">int</span> target = total / 2;
        
        <span class="code-token-keyword">int</span> rowSum = 0;
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> i = 0; i < grid.length; i++) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> num : grid[i]) {
                rowSum += num;
            }
            <span class="code-token-keyword">if</span>(rowSum == target && i != grid.length-1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">int</span> n = grid[0].length;
        <span class="code-token-keyword">int</span>[] colSums = <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[n];
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> j = 0; j < n; j++) {
            <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> i = 0; i < grid.length; i++) {
                colSums[j] += grid[i][j];
            }
        }
        
        <span class="code-token-keyword">int</span> colPrefix = 0;
        <span class="code-token-keyword">for</span>(<span class="code-token-keyword">int</span> j = 0; j < n; j++) {
            colPrefix += colSums[j];
            <span class="code-token-keyword">if</span>(colPrefix == target && j != n-1) {
                <span class="code-token-keyword">return</span> true;
            }
        }
        
        <span class="code-token-keyword">return</span> false;
    }
}</code></pre>
        </div>

        <!-- Python Code -->
        <div class="tab-content" id="python-sol-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">canSplit</span>(self, grid: List[List[int]]) -> bool:
        total = sum(num <span class="code-token-keyword">for</span> row <span class="code-token-keyword">in</span> grid <span class="code-token-keyword">for</span> num <span class="code-token-keyword">in</span> row)
        
        <span class="code-token-keyword">if</span> total % 2 != 0:
            <span class="code-token-keyword">return</span> False
        
        target = total // 2
        current = 0
        
        <span class="code-token-comment"># Check horizontal cuts</span>
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(len(grid)):
            current += sum(grid[i])
            <span class="code-token-keyword">if</span> current == target <span class="code-token-keyword">and</span> i != len(grid)-1:
                <span class="code-token-keyword">return</span> True
        
        <span class="code-token-comment"># Check vertical cuts</span>
        <span class="code-token-keyword">if</span> len(grid[0]) == 1:
            <span class="code-token-keyword">return</span> False
            
        col_sums = [sum(row[j] <span class="code-token-keyword">for</span> row <span class="code-token-keyword">in</span> grid) <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> range(len(grid[0]))]
        current_col = 0
        
        <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> range(len(col_sums)):
            current_col += col_sums[j]
            <span class="code-token-keyword">if</span> current_col == target <span class="code-token-keyword">and</span> j != len(col_sums)-1:
                <span class="code-token-keyword">return</span> True
        
        <span class="code-token-keyword">return</span> False</code></pre>
        </div>
      </div>
      <div class="callout note">
        <strong>Optimization Insight:</strong> Early termination when checking row sums reduces unnecessary column calculations.
      </div>
    </div>

    <hr />

    <h2>Approach Comparison</h2>
    <table>
      <thead>
        <tr>
          <th>Approach</th>
          <th>Time</th>
          <th>Space</th>
          <th>Key Feature</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Prefix Sum</td>
          <td>O(m*n)</td>
          <td>O(n)</td>
          <td>Optimal for large grids</td>
        </tr>
        <tr>
          <td>Brute Force</td>
          <td>O(m^2*n + n^2*m)</td>
          <td>O(1)</td>
          <td>Impractical for large inputs</td>
        </tr>
      </tbody>
    </table>

    <div class="callout warning">
      <strong>Important:</strong> The vertical cut check must be skipped for single-column grids to avoid invalid partitions.
    </div>

    <hr />

    <h2>Edge Case Analysis</h2>
    <h3>1. Single Row Grid</h3>
    <pre><code>Input: [[1,1]] → Output: true (vertical cut)</code></pre>

    <h3>2. Single Column Grid</h3>
    <pre><code>Input: [[2],[2]] → Output: true (horizontal cut)</code></pre>

    <h3>3. Minimum Valid Grid</h3>
    <pre><code>Input: [[1,1]] → Output: true</code></pre>

    <div class="callout danger">
      <strong>Pitfall:</strong> Always verify cuts don't create empty sections (check i != m-1 and j != n-1).
    </div>

    <hr />

    <h2>Frequently Asked Questions</h2>

    <div class="faq-section">
      <details>
        <summary>1. Why check total parity first?</summary>
        <p>Odd totals can't be split into two equal integer sums, providing early exit.</p>
      </details>

      <details>
        <summary>2. How to handle empty sections?</summary>
        <p>We ensure cuts aren't at grid edges using i != m-1 and j != n-1 checks.</p>
      </details>

      <details>
        <summary>3. Why process rows before columns?</summary>
        <p>Row checks often complete faster, enabling early returns for better performance.</p>
      </details>

      <details>
        <summary>4. How does column sum calculation work?</summary>
        <p>We transpose the grid and sum columns using list comprehensions for efficiency.</p>
      </details>

      <details>
        <summary>5. What's the maximum grid size handled?</summary>
        <p>Efficiently handles max constraints (m*n ≤ 1e5) with linear time complexity.</p>
      </details>

      <details>
        <summary>6. Can we optimize space further?</summary>
        <p>Yes by calculating column sums during iteration, but complicates code structure.</p>
      </details>

      <details>
        <summary>7. How to verify correct partitioning?</summary>
        <p>Verify sum(left/top) = sum(right/bottom) = total/2 with non-empty sections.</p>
      </details>

      <details>
        <summary>8. Why use prefix sums?</summary>
        <p>Allows O(1) sum comparison after each row/column instead of recalculating.</p>
      </details>

      <details>
        <summary>9. Handle varying row lengths?</summary>
        <p>Problem constraints ensure rectangular grids (all rows same length).</p>
      </details>

      <details>
        <summary>10. Real-world applications?</summary>
        <p>Data partitioning, load balancing, and resource allocation systems.</p>
      </details>
    </div>

    <div class="callout">
      <strong>Final Analysis:</strong> This problem demonstrates efficient matrix traversal techniques and mathematical optimization for partition problems. The solution leverages prefix sums and early termination checks to achieve optimal performance.
    </div>
  </main>

  <div id="footer"></div>

  <script>
    // Reuse the same JavaScript from previous post
    document.addEventListener('DOMContentLoaded', function() {
      // Tab functionality
      document.querySelectorAll('.code-tabs').forEach(container => {
        const tabButtons = container.querySelectorAll('.tab-button');
        const tabContents = container.querySelectorAll('.tab-content');
        
        // Initialize first tab
        if (!container.querySelector('.tab-button.active')) {
          tabButtons[0]?.classList.add('active');
          tabContents[0]?.classList.add('active');
        }
        
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            const tabName = button.getAttribute('data-tab');
            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            button.classList.add('active');
            container.querySelector(`#${tabName}-tab`).classList.add('active');
          });
        });
      });
      
      // Copy button functionality
      document.querySelectorAll('.code-copy').forEach(button => {
        button.addEventListener('click', () => {
          const activeTab = button.closest('.code-container').querySelector('.tab-content.active');
          const code = activeTab.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = 'Copied!';
            setTimeout(() => button.textContent = 'Copy Code', 2000);
          });
        });
      });

      // Load header and footer
      fetch("../components/header.html")
        .then((response) => response.text())
        .then((data) => {
          document.getElementById("header").innerHTML = data;
        });

      fetch("../components/footer.html")
        .then((response) => response.text())
        .then((data) => {
          document.getElementById("footer").innerHTML = data;
        });
    });
  </script>
</body>
</html>