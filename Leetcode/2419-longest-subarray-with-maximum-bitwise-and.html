<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LeetCode 2419 | Longest Subarray With Maximum Bitwise AND</title>
  <meta name="description"
    content="Optimal O(n) solution with frequency counting. Learn multiple methods to solve the maximum bitwise AND subarray problem with detailed implementations." />
  <meta name="keywords"
    content="LeetCode 2419, Maximum Bitwise AND, Bitwise AND subarray, Array manipulation, Frequency counting, Algorithm optimization, LeetCode premium problem, coding interview preparation, bitwise operations, array traversal, algopush, Algorithm, Programming, Coding Interview, LeetCode Medium Problem, Competitive Programming, leetcode, leetcode problem of the day, leetcode contest question, leetcode easy question, leetcode medium question, leetcode daily question, Leetcode dsa interview question, sde interview question" />
  <meta name="author" content="Algopush" />
  <link rel="canonical" href="https://algopush.com/Leetcode/2419-longest-subarray-with-maximum-bitwise-and.html">

  <!-- Favicon -->
  <link rel="icon" href="../components/favicon.png" type="image/x-icon">
  <link rel="apple-touch-icon" href="../components/favicon.png">

  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="LeetCode 2419: Longest Subarray With Maximum Bitwise AND">
  <meta property="og:description"
    content="Optimal O(n) solution with frequency counting. Learn multiple methods to solve this bitwise AND problem.">
  <meta property="og:image" content="https://algopush.com/Leetcode/Images/2419.png">
  <meta property="og:url" content="https://algopush.com/Leetcode/2419-longest-subarray-with-maximum-bitwise-and.html">
  <meta property="og:type" content="article">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="LeetCode 2419: Longest Subarray With Maximum Bitwise AND">
  <meta name="twitter:description"
    content="Solve bitwise AND problems with frequency counting. Code examples in C++, Java, and Python.">
  <meta name="twitter:image" content="https://algopush.com/Leetcode/Images/2419.png">

  <!-- Structured Data for SEO -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Longest Subarray With Maximum Bitwise AND",
      "url": "https://algopush.com/Leetcode/2419-longest-subarray-with-maximum-bitwise-and.html",
      "image": "https://algopush.com/Leetcode/Images/2419.png",
      "author": {
        "@type": "Organization",
        "name": "Algopush",
        "url": "https://algopush.com"
      },
      "datePublished": "2025-07-31",
      "dateModified": "2025-07-31",
      "publisher": {
        "@type": "Organization",
        "name": "Algopush",
        "logo": {
          "@type": "ImageObject",
          "url": "https://algopush.com/components/logo.png"
        }
      }
    }
  </script>

  <style>
    /* CSS styles identical to previous post */
    :root {
      --primary-color: #102c41;
      --secondary-color: #196391;
      --accent-color: #102c41;
      --meta-color: #db5305;
      --light-bg: #f5f9fc;
      --highlight-color: #f5f9fc;
      --text-color: black;
      --light-text: #7f8c8d;
      --border-radius: 6px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
      --callout-tip: #e8f8f5;
      --callout-note: #eaf2f8;
      --callout-warning: #fef5e7;
      --callout-danger: #ffebee;
      --callout-tip-border: #1abc9c;
      --callout-note-border: #3498db;
      --callout-warning-border: #f39c12;
      --callout-danger-border: #f44336;
    }

    /* Base Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background-color: var(--light-bg);
      color: var(--text-color);
      line-height: 1.7;
      font-size: 1.05rem;
    }

    /* Main Content Container */
    main {
      max-width: 920px;
      margin: 2rem auto;
      padding: 2rem;
      background: #fff;
      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius);
    }

    /* Problem Visualization Image */
    .problem-visual {
      max-width: 100%;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
      text-align: center;
    }

    .problem-visual img {
      max-width: 100%;
      height: auto;
      max-height: 400px;
      display: inline-block;
    }

    /* Typography */
    h1,
    h2,
    h3,
    h4 {
      color: var(--primary-color);
      font-weight: 600;
      margin-top: 1.5rem;
      margin-bottom: 0.8rem;
      line-height: 1.3;
    }

    h1 {
      font-size: 2rem;
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 0.5rem;
    }

    h2 {
      font-size: 1.6rem;
      border-left: 4px solid var(--accent-color);
      padding-left: 0.8rem;
      margin-top: 2.5rem;
    }

    h3 {
      font-size: 1.3rem;
      color: var(--secondary-color);
      margin-top: 1.8rem;
    }

    a {
      color: var(--accent-color);
      text-decoration: none;
      transition: var(--transition);
    }

    a:hover {
      color: var(--primary-color);
      text-decoration: underline;
    }

    hr {
      border: 0;
      height: 1px;
      background: #ddd;
      margin: 2rem 0;
    }

    /* Code Blocks */
    pre {
      background: #f8f9fa;
      padding: 1.2rem;
      border-radius: var(--border-radius);
      overflow-x: auto;
      border-left: 4px solid var(--accent-color);
      font-size: 0.95rem;
      line-height: 1.5;
      margin: 1rem 0;
    }

    code {
      font-family: monospace;
      color: #2c3e50;
    }

    .highlight {
      background: var(--highlight-color);
      padding: 1rem;
      border-radius: var(--border-radius);
      margin: 1.5rem 0;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    th,
    td {
      padding: 0.8rem;
      text-align: center;
      border: 1px solid #ddd;
    }

    th {
      background-color: var(--primary-color);
      color: white;
      font-weight: 500;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    /* Code Container */
    .code-container {
      position: relative;
      margin: 1rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    .code-header {
      background: var(--primary-color);
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: white;
    }

    .code-filename {
      font-weight: 600;
    }

    .code-copy {
      background: white;
      color: var(--primary-color);
      border: none;
      padding: 0.25rem 0.75rem;
      border-radius: 3px;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 500;
    }

    .code-copy:hover {
      background: var(--highlight-color);
    }

    /* Code Syntax Highlighting */
    .code-token-keyword {
      color: #d73a49;
    }

    .code-token-function {
      color: #6f42c1;
    }

    .code-token-comment {
      color: #6a737d;
      font-style: italic;
    }

    .code-token-string {
      color: #032f62;
    }

    .code-token-number {
      color: #005cc5;
    }

    /* Tabs */
    .code-tabs {
      margin: 0.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    .tab-buttons {
      display: flex;
      background: #eaecee;
      border-bottom: 1px solid #ddd;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .tab-button {
      padding: 0.7rem 1.2rem;
      background: transparent;
      border: none;
      cursor: pointer;
      font-weight: 500;
      color: var(--text-color);
      transition: var(--transition);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .tab-button.active {
      background: var(--primary-color);
      color: white;
    }

    .tab-button:hover:not(.active) {
      background: #d5dbdb;
    }

    .tab-content {
      display: none;
      background: white;
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    /* FAQ Section */
    .faq-section {
      margin: 2rem 0;
    }

    .faq-section details {
      margin: 0.8rem 0;
      padding: 0.1rem;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      background: white;
      transition: var(--transition);
    }

    .faq-section details[open] {
      border-color: var(--accent-color);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      background: #f9f9f9;
    }

    .faq-section summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--primary-color);
      padding: 0.8rem;
      outline: none;
      transition: var(--transition);
    }

    .faq-section summary:hover {
      color: var(--accent-color);
      background: #f5f5f5;
    }

    .faq-section p {
      margin-top: 1rem;
      padding: 0 1rem 1rem;
    }

    /* Breadcrumb Navigation */
    .breadcrumb {
      padding: 0.8rem 1rem;
      background: linear-gradient(to right, #f5f5f5, white);
      border-radius: var(--border-radius);
      margin-bottom: 2rem;
      font-size: 0.9rem;
    }

    .breadcrumb a {
      color: var(--secondary-color);
    }

    .breadcrumb a:hover {
      text-decoration: underline;
    }

    /* Problem Metadata */
    .problem-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin: 1.5rem 0;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: var(--border-radius);
    }

    .meta-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .meta-item .label {
      font-weight: 600;
      color: var(--meta-color);
    }

    /* Callout Boxes */
    .callout {
      padding: 1rem 1.5rem;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      border-left: 4px solid;
    }

    .callout.tip {
      background-color: var(--callout-tip);
      border-color: var(--callout-tip-border);
    }

    .callout.note {
      background-color: var(--callout-note);
      border-color: var(--callout-note-border);
    }

    .callout.warning {
      background-color: var(--callout-warning);
      border-color: var(--callout-warning-border);
    }

    .callout.danger {
      background-color: var(--callout-danger);
      border-color: var(--callout-danger-border);
    }

    .callout strong {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }

    /* Visualization Container */
    .visual-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin: 2rem 0;
    }

    .visual-item {
      flex: 1;
      min-width: 300px;
      padding: 1rem;
      border-radius: var(--border-radius);
      background: #f8f9fa;
      box-shadow: var(--box-shadow);
    }

    .visual-item h4 {
      color: var(--secondary-color);
      margin-top: 0;
      border-bottom: 1px solid #ddd;
      padding-bottom: 0.5rem;
    }

    .grid-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }

    .grid-item {
      padding: 1rem;
      text-align: center;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      background: white;
    }

    .grid-item.max {
      background-color: #e8f8f5;
      border-color: #1abc9c;
    }

    .grid-item.other {
      background-color: #eaf2f8;
      border-color: #3498db;
    }

    @keyframes pulse {
      0% {
        background-color: #e6f7ff;
      }

      50% {
        background-color: #b3e0ff;
      }

      100% {
        background-color: #e6f7ff;
      }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      main {
        margin: 1rem;
        padding: 1.5rem;
      }

      h1 {
        font-size: 1.7rem;
      }

      h2 {
        font-size: 1.4rem;
      }

      .problem-meta {
        flex-direction: column;
      }

      table {
        display: block;
        overflow-x: auto;
      }

      .visual-item {
        min-width: 100%;
      }

      .grid-container {
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      }
    }

    @media (max-width: 480px) {
      main {
        padding: 1rem;
      }

      h1 {
        font-size: 1.5rem;
      }

      h2 {
        font-size: 1.2rem;
      }

      pre {
        padding: 0.8rem;
        font-size: 0.85rem;
      }

      .tab-button {
        padding: 0.6rem;
        font-size: 0.9rem;
      }

      .code-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .code-copy {
        margin-top: 0.5rem;
      }
    }
  </style>
</head>

<body>
  <div id="header"></div>

  <main>
    <div class="breadcrumb">
      <a href="https://algopush.com">Home</a> &gt;
      <a href="https://algopush.com/Leetcode/leetcode.html">LeetCode</a> &gt;
      <span>2419. Longest Subarray With Maximum Bitwise AND</span>
    </div>

    <div class="problem-visual">
      <img src="https://algopush.com/Leetcode/Images/2419.png" alt="Bitwise AND visualization" loading="lazy">
    </div>

    <h1>2419: Longest Subarray With Maximum Bitwise AND</h1>

    <div class="problem-meta">
      <div class="meta-item">
        <span class="label">Difficulty:</span>
        <span class="value">Medium</span>
      </div>
      <div class="meta-item">
        <span class="label">Topics:</span>
        <span class="value">Bitwise Operations, Array Manipulation</span>
      </div>
      <div class="meta-item">
        <span class="label">Companies:</span>
        <span class="value">Google, Amazon, Microsoft</span>
      </div>
    </div>

    <div class="callout tip">
      <strong>Pro Tip:</strong> The maximum bitwise AND of any subarray is always equal to the maximum element in the
      array. The longest subarray with this value is the longest contiguous segment of the maximum element.
    </div>

    <h2>Problem Statement</h2>
    <p>Given an integer array <code>nums</code>, find the length of the longest contiguous subarray where the bitwise
      AND of the subarray equals the maximum possible bitwise AND of any subarray.</p>
    <p>The bitwise AND of a subarray is the bitwise AND of all integers in that contiguous segment.</p>

    <div class="visual-container">
      <div class="visual-item">
        <h4>Example 1</h4>
        <p><strong>Input:</strong> nums = [1,2,3,3,2,2]</p>
        <p><strong>Output:</strong> 2</p>
        <p><strong>Explanation:</strong> The maximum bitwise AND is 3. The longest contiguous subarray with bitwise AND
          3 is [3,3] (length 2).</p>
      </div>

      <div class="visual-item">
        <h4>Example 2</h4>
        <p><strong>Input:</strong> nums = [1,2,3,4]</p>
        <p><strong>Output:</strong> 1</p>
        <p><strong>Explanation:</strong> The maximum bitwise AND is 4. The only contiguous subarray with bitwise AND 4
          is [4] (length 1).</p>
      </div>
    </div>

    <div class="callout note">
      <strong>Problem Link:</strong>
      <a href="https://leetcode.com/problems/longest-subarray-with-maximum-bitwise-and/" target="_blank"
        rel="noopener noreferrer">
        View on LeetCode ↗
      </a>
    </div>

    <hr />

    <h2>Key Insight</h2>
    <p>The solution relies on two crucial observations:</p>
    <ol>
      <li>The maximum possible bitwise AND of any subarray is equal to the maximum element in the array
        (<code>max_val</code>)</li>
      <li>The longest subarray with bitwise AND equal to <code>max_val</code> is the longest contiguous segment of
        <code>max_val</code> in the original array</li>
    </ol>

    <div class="grid-container">
      <div class="grid-item max">3</div>
      <div class="grid-item max">3</div>
      <div class="grid-item other">2</div>
      <div class="grid-item other">1</div>
      <div class="grid-item max">3</div>
    </div>
    <p class="callout">The longest contiguous segment of max value (3) has length 2. We cannot connect non-adjacent 3's
      without breaking contiguity.</p>

    <div class="callout warning">
      <strong>Important:</strong> While we can delete elements, the problem requires selecting a contiguous subarray
      from the <strong>remaining elements in their original order</strong>. We cannot reorder elements, only delete
      some.
    </div>

    <hr />

    <h2>Optimal Approach: Find Longest Contiguous Segment</h2>
    <p>This approach finds the longest contiguous segment of the maximum value in the original array.</p>

    <h3>Algorithm Steps</h3>
    <ol>
      <li>Find the maximum value in the array</li>
      <li>Traverse the array to find the longest contiguous segment of this maximum value</li>
      <li>Return the length of this segment</li>
    </ol>

    <h3>Why This Works</h3>
    <p>The maximum bitwise AND value can only be achieved by subarrays consisting entirely of the maximum element. The
      longest such subarray is the longest contiguous segment of this value in the original array.</p>

    <h3>Complexity Analysis</h3>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>O(n)</td>
          <td>O(1)</td>
        </tr>
      </tbody>
    </table>
    <p>Where <code>n</code> is the length of the array. We traverse the array once to find the maximum and once to find
      the longest segment.</p>

    <div class="code-container">
      <div class="code-header">
        <span class="code-filename">Optimal Solution</span>
        <button class="code-copy">Copy Code</button>
      </div>
      <div class="code-tabs">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="cpp-opt">C++</button>
          <button class="tab-button" data-tab="java-opt">Java</button>
          <button class="tab-button" data-tab="python-opt">Python</button>
        </div>

        <!-- C++ Code -->
        <div class="tab-content active" id="cpp-opt-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">int</span> <span class="code-token-function">longestSubarray</span>(vector<<span class="code-token-keyword">int</span>>& nums) {
        <span class="code-token-comment">// Find the maximum value</span>
        <span class="code-token-keyword">int</span> max_val = *max_element(nums.begin(), nums.end());
        <span class="code-token-keyword">int</span> max_len = 0;
        <span class="code-token-keyword">int</span> curr_len = 0;
        
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : nums) {
            <span class="code-token-keyword">if</span> (num == max_val) {
                curr_len++;
                max_len = max(max_len, curr_len);
            } <span class="code-token-keyword">else</span> {
                curr_len = 0;
            }
        }
        
        <span class="code-token-keyword">return</span> max_len;
    }
};</code></pre>
        </div>

        <!-- Java Code -->
        <div class="tab-content" id="java-opt-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">int</span> <span class="code-token-function">longestSubarray</span>(<span class="code-token-keyword">int</span>[] nums) {
        <span class="code-token-comment">// Find the maximum value</span>
        <span class="code-token-keyword">int</span> max_val = Integer.MIN_VALUE;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : nums) {
            <span class="code-token-keyword">if</span> (num > max_val) max_val = num;
        }
        
        <span class="code-token-keyword">int</span> max_len = 0;
        <span class="code-token-keyword">int</span> curr_len = 0;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : nums) {
            <span class="code-token-keyword">if</span> (num == max_val) {
                curr_len++;
                max_len = Math.max(max_len, curr_len);
            } <span class="code-token-keyword">else</span> {
                curr_len = 0;
            }
        }
        
        <span class="code-token-keyword">return</span> max_len;
    }
}</code></pre>
        </div>

        <!-- Python Code -->
        <div class="tab-content" id="python-opt-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">longestSubarray</span>(self, nums: List[<span class="code-token-keyword">int</span>]) -> <span class="code-token-keyword">int</span>:
        <span class="code-token-comment"># Find the maximum value</span>
        max_val = max(nums)
        max_len = curr_len = 0
        
        <span class="code-token-keyword">for</span> num <span class="code-token-keyword">in</span> nums:
            <span class="code-token-keyword">if</span> num == max_val:
                curr_len += 1
                max_len = max(max_len, curr_len)
            <span class="code-token-keyword">else</span>:
                curr_len = 0
                
        <span class="code-token-keyword">return</span> max_len</code></pre>
        </div>
      </div>
      <div class="callout note">
        <strong>Implementation Note:</strong> This approach efficiently finds the solution in O(n) time with O(1) space
        by leveraging a single pass after finding the maximum value.
      </div>
    </div>

    <hr />

    <h2>Alternative Approach: Single Pass with Max Tracking</h2>
    <p>This approach combines finding the maximum value and tracking contiguous segments in a single pass.</p>

    <h3>Algorithm Steps</h3>
    <ol>
      <li>Initialize variables for current maximum value, current segment length, and maximum segment length</li>
      <li>Traverse the array:
        <ul>
          <li>Update current segment length when encountering current maximum</li>
          <li>Reset when encountering a new maximum or different value</li>
          <li>Track the longest segment length</li>
        </ul>
      </li>
      <li>Return the maximum segment length</li>
    </ol>

    <h3>Complexity Analysis</h3>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>O(n)</td>
          <td>O(1)</td>
        </tr>
      </tbody>
    </table>
    <p>Slightly more efficient as it finds the maximum and longest segment in a single pass.</p>

    <div class="code-container">
      <div class="code-header">
        <span class="code-filename">Single Pass Solution</span>
        <button class="code-copy">Copy Code</button>
      </div>
      <div class="code-tabs">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="cpp-single">C++</button>
          <button class="tab-button" data-tab="java-single">Java</button>
          <button class="tab-button" data-tab="python-single">Python</button>
        </div>

        <!-- C++ Code -->
        <div class="tab-content active" id="cpp-single-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">int</span> <span class="code-token-function">longestSubarray</span>(vector<<span class="code-token-keyword">int</span>>& nums) {
        <span class="code-token-keyword">int</span> max_val = INT_MIN;
        <span class="code-token-keyword">int</span> curr_len = 0;
        <span class="code-token-keyword">int</span> max_len = 0;
        
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : nums) {
            <span class="code-token-keyword">if</span> (num > max_val) {
                <span class="code-token-comment">// New maximum found</span>
                max_val = num;
                max_len = 1;
                curr_len = 1;
            } <span class="code-token-keyword">else</span> <span class="code-token-keyword">if</span> (num == max_val) {
                <span class="code-token-comment">// Continue current segment</span>
                curr_len++;
                max_len = max(max_len, curr_len);
            } <span class="code-token-keyword">else</span> {
                <span class="code-token-comment">// Reset current segment</span>
                curr_len = 0;
            }
        }
        
        <span class="code-token-keyword">return</span> max_len;
    }
};</code></pre>
        </div>

        <!-- Java Code -->
        <div class="tab-content" id="java-single-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">int</span> <span class="code-token-function">longestSubarray</span>(<span class="code-token-keyword">int</span>[] nums) {
        <span class="code-token-keyword">int</span> max_val = Integer.MIN_VALUE;
        <span class="code-token-keyword">int</span> curr_len = 0;
        <span class="code-token-keyword">int</span> max_len = 0;
        
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : nums) {
            <span class="code-token-keyword">if</span> (num > max_val) {
                max_val = num;
                max_len = 1;
                curr_len = 1;
            } <span class="code-token-keyword">else</span> <span class="code-token-keyword">if</span> (num == max_val) {
                curr_len++;
                max_len = Math.max(max_len, curr_len);
            } <span class="code极客token-keyword">else</span> {
                curr_len = 0;
            }
        }
        
        <span class="code-token-keyword">return</span> max_len;
    }
}</code></pre>
        </div>

        <!-- Python Code -->
        <div class="tab-content" id="python-single-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">极客</span> <span class="code-token-function">longestSubarray</span>(self, nums: List[<span class="code-token-keyword">int</span>]) -> <span class="code-token-keyword">int</span>:
        max_val = float('-inf')
        curr_len = 0
        max_len = 0
        
        <span class="code-token-keyword">for</span> num <span class="code-token-keyword">in</span> nums:
            <span class="code-token-keyword">if</span> num > max_val:
                <span class="code-token-comment"># New maximum found</span>
                max_val = num
                max_len = 1
                curr_len = 1
            <span class="code-token-keyword">elif</span> num == max_val:
                <span class="code-token-comment"># Continue current segment</span>
                curr_len += 1
                max_len = max(max_len, curr_len)
            <span class="code-token-keyword">else</span>:
                <span class="code-token-comment"># Reset current segment</span>
                curr_len = 0
                
        <span class="code-token-keyword">return</span> max_len</code></pre>
        </div>
      </div>
      <div class="callout note">
        <strong>Implementation Note:</strong> This approach is slightly more efficient as it finds the maximum and
        tracks segments in a single pass. However, both approaches have the same time complexity.
      </div>
    </div>

    <hr />

    <h2>Frequently Asked Questions</h2>

    <div class="faq-section">
      <details>
        <summary>1. Why is the maximum bitwise AND equal to the maximum element?</summary>
        <p>For any two numbers, a & b ≤ min(a, b) ≤ max(a, b). Therefore, the bitwise AND of any subarray cannot exceed
          the maximum element in the array. The maximum element itself will have a bitwise AND equal to itself when
          taken alone.</p>
      </details>

      <details>
        <summary>2. Why can we delete elements arbitrarily?</summary>
        <p>The problem allows deleting any number of elements (as long as the array doesn't become empty). This means we
          can remove all non-maximum elements, making all maximum elements contiguous.</p>
      </details>

      <details>
        <summary>3. What if there are multiple maximum values?</summary>
        <p>All occurrences of the maximum value contribute to the solution. After deleting non-max elements, we can form
          a contiguous block of all maximum values.</p>
      </details>

      <details>
        <summary>4. Why not use the longest contiguous segment in the original array?</summary>
        <p>Because deletion allows us to connect non-adjacent maximum values. The problem doesn't require the subarray
          to be contiguous in the original array, only in the modified array after deletion.</p>
      </details>

      <details>
        <summary>5. How does bitwise AND work with multiple numbers?</summary>
        <p>Bitwise AND of multiple numbers only keeps the bits that are set in all numbers. If any number misses a bit
          that's set in the maximum value, the result will be less than the maximum.</p>
      </details>

      <details>
        <summary>6. What's the time complexity of the optimal solution?</summary>
        <p>O(n) since we traverse the array twice: once to find the maximum and once to count its frequency.</p>
      </details>

      <details>
        <summary>7. Can we solve this in a single pass?</summary>
        <p>Yes, we can find the maximum and count its frequency in a single pass, but it requires careful implementation
          to handle the maximum value updates correctly.</p>
      </details>

      <details>
        <summary>8. How large can the input array be?</summary>
        <p>According to constraints, the array length can be up to 10^5, so O(n) solutions are required.</p>
      </details>

      <details>
        <summary>9. What if the array has negative numbers?</summary>
        <p>The constraint states that nums[i] ≥ 1, so negative numbers are not possible.</p>
      </details>

      <details>
        <summary>10. Why is this problem marked as medium difficulty?</summary>
        <p>The key insight (that deletion allows connecting non-adjacent max values) is non-trivial. Many initially
          think about contiguous segments in the original array.</p>
      </details>
    </div>

    <div class="callout">
      <strong>Final Insight:</strong> This problem teaches an important lesson in bitwise operations and array
      manipulation. By recognizing that deletion allows maximum flexibility, we arrive at an elegant O(n) solution
      that's both efficient and intuitive.
    </div>
  </main>

  <div id="footer"></div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      // Tab functionality
      document.querySelectorAll('.code-tabs').forEach(container => {
        const tabButtons = container.querySelectorAll('.tab-button');
        const tabContents = container.querySelectorAll('.tab-content');

        // Initialize first tab
        if (!container.querySelector('.tab-button.active')) {
          tabButtons[0]?.classList.add('active');
          tabContents[0]?.classList.add('active');
        }

        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            const tabName = button.getAttribute('data-tab');
            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            button.classList.add('active');
            container.querySelector(`#${tabName}-tab`).classList.add('active');
          });
        });
      });

      // Copy button functionality
      document.querySelectorAll('.code-copy').forEach(button => {
        button.addEventListener('click', () => {
          const activeTab = button.closest('.code-container').querySelector('.tab-content.active');
          const code = activeTab.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            setTimeout(() => button.textContent = originalText, 2000);
          });
        });
      });

      // Load header and footer
      fetch("../components/header.html")
        .then((response) => response.text())
        .then((data) => {
          document.getElementById("header").innerHTML = data;
        });

      fetch("../components/footer.html")
        .then((response) => response.text())
        .then((data) => {
          document.getElementById("footer").innerHTML = data;
        });
    });
  </script>
</body>

</html>