<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      LeetCode 2302 Solution | Count Subarrays With Score Less Than K | Algopush
    </title>
    <meta
      name="description"
      content="Optimal solution for LeetCode 2302 using sliding window technique. Learn how to count subarrays where product of sum and length is less than k with C++, Java, and Python implementations."
    />
    <meta
      name="keywords"
      content="LeetCode 2302, Count Subarrays With Score Less Than K, Sliding Window algorithm, Array problems, Coding interview preparation, Algorithm optimization, LeetCode hard problems, C++ Java Python solutions, Time complexity analysis, Algopush tutorials"
    />
    <meta name="author" content="Algopush" />
    <meta
      property="og:title"
      content="LeetCode 2302 Solution | Count Subarrays With Score Less Than K"
    />
    <meta
      property="og:description"
      content="Master the sliding window approach to solve LeetCode 2302 efficiently. Complete guide with multiple implementations and complexity analysis."
    />
    <meta
      property="og:image"
      content="https://algopush.com/Leetcode/Images/2302.png"
    />
    <meta
      property="og:url"
      content="https://algopush.com/Leetcode/2302-count-subarrays-with-score-less-than-k.html"
    />
    <meta property="og:type" content="article" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="LeetCode 2302 Solution | Count Subarrays With Score Less Than K"
    />
    <meta
      name="twitter:description"
      content="Optimal sliding window solution for LeetCode 2302 with detailed explanations and code implementations."
    />
    <meta
      name="twitter:image"
      content="https://algopush.com/Leetcode/Images/2302.png"
    />
    <meta name="rating" content="general" />
    <meta http-equiv="content-language" content="en" />
    <meta name="distribution" content="global" />
    <meta name="robots" content="index, follow" />
    <link
      rel="canonical"
      href="https://algopush.com/Leetcode/2302-count-subarrays-with-score-less-than-k.html"
    />

    <!-- Favicon -->
    <!-- <link
      rel="icon"
      href="https://algopush.com/components/favicon.png"
      type="image/x-icon"
    />
    <link
      rel="apple-touch-icon"
      href="https://algopush.com/components/favicon.png"
    /> -->

    <!-- Preload important resources -->
    <link rel="preload" href="../script.js" as="script" />
    <link
      rel="preload"
      href="https://algopush.com/styles.css"
      as="style"
    />

    <!-- Structured Data for enhanced SEO -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "TechArticle",
        "headline": "LeetCode 2302 Solution: Count Subarrays With Score Less Than K",
        "description": "Detailed explanation of sliding window approach to solve LeetCode 2302 with code examples in C++, Java, and Python.",
        "author": {
          "@type": "Organization",
          "name": "Algopush",
          "url": "https://algopush.com"
        },
        "image": "https://algopush.com/Leetcode/Images/2302.png",
        "datePublished": "2023-04-28",
        "dateModified": "2023-04-28",
        "publisher": {
          "@type": "Organization",
          "name": "Algopush",
          "logo": {
            "@type": "ImageObject",
            "url": "https://algopush.com/components/logo.png"
          }
        },
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://algopush.com/Leetcode/2302-count-subarrays-with-score-less-than-k.html"
        },
        "speakable": {
          "@type": "SpeakableSpecification",
          "xPath": [
            "/html/head/title",
            "/html/head/meta[@name='description']/@content"
          ],
          "cssSelector": ["h1", "main p:first-of-type"]
        }
      }
    </script>

    <script>
      // Function to handle tab switching
      function openTab(evt, tabName) {
        // Get all elements with class="tab-content" and hide them
        const tabContents = document.getElementsByClassName("tab-content");
        for (let i = 0; i < tabContents.length; i++) {
          tabContents[i].classList.remove("active");
        }

        // Get all elements with class="tab-button" and remove the "active" class
        const tabButtons = document.getElementsByClassName("tab-button");
        for (let i = 0; i < tabButtons.length; i++) {
          tabButtons[i].classList.remove("active");
        }

        // Show the current tab and add the "active" class to the button that opened the tab
        document.getElementById(tabName).classList.add("active");
        evt.currentTarget.classList.add("active");
      }

      // Initialize the first tab as active by default
      document.addEventListener("DOMContentLoaded", function () {
        const defaultTab = document.querySelector(".tab-button");
        if (defaultTab) {
          defaultTab.click();
        }

        // Load header and footer
        fetch("../components/header.html")
          .then((response) => response.text())
          .then((data) => {
            document.getElementById("header").innerHTML = data;
          });

        fetch("../components/footer.html")
          .then((response) => response.text())
          .then((data) => {
            document.getElementById("footer").innerHTML = data;
          });
      });
    </script>

    <style>
      :root {
        --primary-color: #102c41;
        --secondary-color: #196391;
        --accent-color: #102c41;
        --light-bg: #f5f9fc;
        --highlight-color: #f5f9fc;
        --text-color: black;
        --light-text: #7f8c8d;
        --border-radius: 6px;
        --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        --transition: all 0.3s ease;
      }

      /* Base Styles */
      body {
        margin: 0;
        padding: 0;
        font-family: "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
          "Helvetica Neue", sans-serif;
        background-color: var(--light-bg);
        color: var(--text-color);
        line-height: 1.7;
        font-size: 1.05rem;
      }

      /* Main Content Container */
      main {
        max-width: 920px;
        margin: 2rem auto;
        padding: 2rem;
        background: #fff;
        box-shadow: var(--box-shadow);
        border-radius: var(--border-radius);
      }

      /* Typography */
      h1,
      h2,
      h3,
      h4 {
        color: var(--primary-color);
        font-weight: 600;
        margin-top: 1.8rem;
        margin-bottom: 1rem;
        line-height: 1.3;
      }

      h1 {
        font-size: 2.2rem;
        border-bottom: 2px solid var(--primary-color);
        padding-bottom: 0.5rem;
      }

      h2 {
        font-size: 1.7rem;
        border-left: 4px solid var(--accent-color);
        padding-left: 0.8rem;
      }

      h3 {
        font-size: 1.4rem;
        color: var(--secondary-color);
      }

      a {
        color: var(--accent-color);
        text-decoration: none;
        transition: var(--transition);
      }

      a:hover {
        color: var(--primary-color);
        text-decoration: underline;
      }

      /* Code Blocks */
      pre {
        background: #f8f9fa;
        padding: 1.2rem;
        border-radius: var(--border-radius);
        overflow-x: auto;
        border-left: 4px solid var(--accent-color);
        font-size: 0.95rem;
        line-height: 1.5;
      }

      code {
        font-family: monospace;
        color: #2c3e50;
      }

      .highlight {
        background: var(--highlight-color);
        padding: 1rem;
        border-radius: var(--border-radius);
        margin: 1.5rem 0;
      }

      /* Tables */
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 1.5rem 0;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      th,
      td {
        padding: 0.8rem;
        text-align: center;
        border: 1px solid #ddd;
      }

      th {
        background-color: var(--primary-color);
        color: white;
        font-weight: 500;
      }

      tr:nth-child(even) {
        background-color: #f2f2f2;
      }

      /* Tabs */
      .code-tabs {
        margin: 2rem 0;
        border-radius: var(--border-radius);
        overflow: hidden;
        box-shadow: var(--box-shadow);
      }

      .tab-buttons {
        display: flex;
        background: #eaecee;
        border-bottom: 1px solid #ddd;
      }

      .tab-button {
        padding: 0.7rem 1.2rem;
        background: transparent;
        border: none;
        cursor: pointer;
        font-weight: 500;
        color: var(--text-color);
        transition: var(--transition);
      }

      .tab-button.active {
        background: var(--primary-color);
        color: white;
      }

      .tab-button:hover:not(.active) {
        background: #d5dbdb;
      }

      .tab-content {
        display: none;
        background: white;
      }

      .tab-content.active {
        display: block;
        animation: fadeIn 0.3s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      /* FAQ Section */
      .faq-section {
        margin: 2rem 0;
      }

      .faq-section details {
        margin: 0.8rem 0;
        padding: 0.1rem;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        background: white;
        transition: var(--transition);
      }

      .faq-section details[open] {
        border-color: var(--accent-color);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .faq-section summary {
        cursor: pointer;
        font-weight: 600;
        color: var(--primary-color);
        padding: 0.5rem;
        outline: none;
      }

      .faq-section summary:hover {
        color: var(--accent-color);
      }

      .faq-section p {
        margin-top: 1rem;
        padding-left: 1rem;
      }

      /* Breadcrumb Navigation */
      .breadcrumb {
        padding: 0.8rem 1rem;
        background: #f5f5f5;
        border-radius: var(--border-radius);
        margin-bottom: 2rem;
        font-size: 0.9rem;
      }

      .breadcrumb a {
        color: var(--secondary-color);
      }

      .breadcrumb a:hover {
        text-decoration: underline;
      }

      /* Problem Metadata */
      .problem-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin: 1.5rem 0;
        padding: 1rem;
        background: #f8f9fa;
        border-radius: var(--border-radius);
      }

      .meta-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
      }

      .meta-item .label {
        font-weight: 600;
        color: var(--primary-color);
      }

      /* Callout Boxes */
      .callout {
        padding: 1rem 1.5rem;
        margin: 1.5rem 0;
        border-radius: var(--border-radius);
        border-left: 4px solid;
      }

      .callout.tip {
        background-color: #e8f8f5;
        border-color: #1abc9c;
      }

      .callout.note {
        background-color: #eaf2f8;
        border-color: #3498db;
      }

      .callout.warning {
        background-color: #fef5e7;
        border-color: #f39c12;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        main {
          margin: 1rem;
          padding: 1.5rem;
        }

        h1 {
          font-size: 1.8rem;
        }

        h2 {
          font-size: 1.5rem;
        }

        .problem-meta {
          flex-direction: column;
        }

        table {
          display: block;
          overflow-x: auto;
        }
      }

      @media (max-width: 480px) {
        main {
          padding: 1rem;
        }

        h1 {
          font-size: 1.6rem;
        }

        h2 {
          font-size: 1.3rem;
        }

        pre {
          padding: 0.8rem;
          font-size: 0.85rem;
        }

        .tab-buttons {
          flex-wrap: wrap;
        }

        .tab-button {
          flex: 1 0 auto;
          padding: 0.6rem;
          font-size: 0.9rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- Header will be inserted by JavaScript -->
    <div id="header"></div>

    <!-- Main Content -->
    <main>
      <!-- Breadcrumb Navigation -->
      <div class="breadcrumb">
        <a href="https://algopush.com">Home</a> &gt;
        <a href="https://algopush.com/Leetcode/leetcode.html">LeetCode</a> &gt;
        <span>Problem 2302</span>
      </div>

      <h1>LeetCode 2302: Count Subarrays With Score Less Than K</h1>

      <!-- Problem Metadata -->
      <div class="problem-meta">
        <div class="meta-item">
          <span class="label">Difficulty:</span>
          <span class="value">Hard</span>
        </div>
        <div class="meta-item">
          <span class="label">Topics:</span>
          <span class="value">Arrays, Sliding Window</span>
        </div>
        <div class="meta-item">
          <span class="label">Companies:</span>
          <span class="value">Google, Amazon, Meta</span>
        </div>
      </div>

      <div class="callout tip">
        <strong>Pro Tip:</strong> This problem is an excellent example of when to use the sliding window technique for optimizing subarray calculations. Mastering this pattern will help you solve many array manipulation problems efficiently.
      </div>

      <p>
        The problem "Count Subarrays With Score Less Than K" (LeetCode 2302) requires us to count the number of non-empty subarrays where the product of the subarray's sum and its length is strictly less than a given integer <code>k</code>. This problem tests our ability to optimize subarray calculations and is a classic example of when the sliding window technique shines.
      </p>

      <h2>Problem Statement</h2>
      <p>
        The <strong>score</strong> of an array is defined as the <strong>product of its sum and its length</strong>.
      </p>
      <p>
        Given a positive integer array <code>nums</code> and an integer <code>k</code>, return the number of non-empty subarrays of <code>nums</code> whose score is strictly less than <code>k</code>.
      </p>
      <p>
        A subarray is a contiguous sequence of elements within an array.
      </p>

      <div class="highlight">
        <code>score = (sum of subarray elements) × (length of subarray)</code>
      </div>

      <h3>Constraints</h3>
      <ul>
        <li><code>1 ≤ nums.length ≤ 10<sup>5</sup></code></li>
        <li><code>1 ≤ nums[i] ≤ 10<sup>5</sup></code></li>
        <li><code>1 ≤ k ≤ 10<sup>15</sup></code></li>
      </ul>

      <h2>Problem Link</h2>
      <p>
        <a
          href="https://leetcode.com/problems/count-subarrays-with-score-less-than-k/"
          target="_blank"
          rel="noopener noreferrer"
          >View on LeetCode ↗</a
        >
      </p>

      <h3>Example 1</h3>
<pre><code><b>Input:</b> nums = [2,1,4,3,5], k = 10
<b>Output:</b> 6
<b>Explanation:</b>
The 6 subarrays having scores less than 10 are:
- [2] → score = 2 × 1 = 2
- [1] → 1 × 1 = 1
- [4] → 4 × 1 = 4
- [3] → 3 × 1 = 3
- [5] → 5 × 1 = 5
- [2,1] → (2+1) × 2 = 6
Note that subarrays like [1,4] and [4,3,5] have scores of 10 and 36 respectively,
which are not less than 10.</code></pre>

      <h3>Example 2</h3>
<pre><code><b>Input:</b> nums = [1,1,1], k = 5
<b>Output:</b> 5
<b>Explanation:</b>
Every subarray except [1,1,1] has a score less than 5:
- [1] → 1 × 1 = 1
- [1] → 1 × 1 = 1
- [1] → 1 × 1 = 1
- [1,1] → (1+1) × 2 = 4
- [1,1] → (1+1) × 2 = 4
The subarray [1,1,1] has score (1+1+1) × 3 = 9, which is not less than 5.</code></pre>

      <div class="callout note">
        <strong>Note:</strong> Since all elements are positive, longer subarrays will generally have higher scores, which is why we can optimize using the sliding window approach.
      </div>

      <hr />

      <h2>Approach 1: Brute Force (TLE)</h2>
      <p>
        The brute force approach checks every possible subarray and calculates its score. While straightforward, this approach results in O(n²) time complexity, which is too slow for the upper constraint of n ≤ 10⁵.
      </p>

      <h3>Algorithm Steps</h3>
      <ol>
        <li><strong>Initialize</strong> a counter to zero</li>
        <li><strong>Iterate</strong> through all possible starting indices</li>
        <li><strong>For each starting index</strong>, expand the subarray to the right</li>
        <li><strong>Calculate</strong> the score for each subarray</li>
        <li><strong>Increment</strong> counter if score &lt; k</li>
        <li><strong>Break</strong> early if score ≥ k (since longer subarrays will have higher scores)</li>
        <li><strong>Return</strong> the final count</li>
      </ol>

      <h3>Complexity Analysis</h3>
      <table>
        <thead>
          <tr>
            <th>Time Complexity</th>
            <th>Space Complexity</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>O(n²)</td>
            <td>O(1)</td>
          </tr>
        </tbody>
      </table>

      <p>
        <strong>Why it fails:</strong> For n = 10<sup>5</sup>, the number of operations would be around 10<sup>10</sup>, which is way beyond what's acceptable (typically need to stay under 10<sup>6</sup> operations).
      </p>

      <h3>Implementation</h3>

      <div class="code-tabs">
        <div class="tab-buttons">
          <button
            class="tab-button active"
            onclick="openTab(event, 'cpp-brute')"
          >
            C++
          </button>
          <button class="tab-button" onclick="openTab(event, 'java-brute')">
            Java
          </button>
          <button class="tab-button" onclick="openTab(event, 'python-brute')">
            Python
          </button>
        </div>

        <div id="cpp-brute" class="tab-content active">
          <pre><code>
class Solution {
public:
    long long countSubarrays(vector&lt;int&gt;& nums, long long k) {
        int n = nums.size();
        long long count = 0;
        
        for(int i = 0; i &lt; n; i++) {
            long long sum = 0;
            for(int j = i; j &lt; n; j++) {
                sum += nums[j];
                long long score = sum * (j - i + 1);
                
                if(score &lt; k) {
                    count++;
                } else {
                    break; // Longer subarrays will have higher scores
                }
            }
        }
        
        return count;
    }
};
                </code></pre>
        </div>

        <div id="java-brute" class="tab-content">
          <pre><code>
class Solution {
    public long countSubarrays(int[] nums, long k) {
        int n = nums.length;
        long count = 0;
        
        for(int i = 0; i &lt; n; i++) {
            long sum = 0;
            for(int j = i; j &lt; n; j++) {
                sum += nums[j];
                long score = sum * (j - i + 1);
                
                if(score &lt; k) {
                    count++;
                } else {
                    break; // Longer subarrays will have higher scores
                }
            }
        }
        
        return count;
    }
}
                </code></pre>
        </div>

        <div id="python-brute" class="tab-content">
          <pre><code>
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        n = len(nums)
        count = 0
        
        for i in range(n):
            current_sum = 0
            for j in range(i, n):
                current_sum += nums[j]
                score = current_sum * (j - i + 1)
                
                if score &lt; k:
                    count += 1
                else:
                    break  # Longer subarrays will have higher scores
                    
        return count
                </code></pre>
        </div>
      </div>

      <div class="callout warning">
        <strong>Note:</strong> This solution will result in Time Limit Exceeded (TLE) for large inputs due to its O(n²) time complexity.
      </div>

      <hr />

      <h2>Approach 2: Sliding Window (Optimal)</h2>
      <p>
        The optimal solution uses a sliding window technique to maintain a window where the score is less than <code>k</code>. This approach works because with positive numbers, expanding the window increases the score, and shrinking it decreases the score.
      </p>

      <h3>Key Insights</h3>
      <ul>
        <li>All elements are positive, so expanding window increases score</li>
        <li>For each right pointer, find the smallest left where window is valid</li>
        <li>Number of valid subarrays ending at right is <code>window length</code></li>
      </ul>

      <h3>Algorithm Steps</h3>
      <ol>
        <li><strong>Initialize</strong> left pointer, sum, and count to 0</li>
        <li><strong>Iterate</strong> with right pointer from 0 to n-1</li>
        <li><strong>Add</strong> nums[right] to the current sum</li>
        <li><strong>While</strong> score (sum × window length) ≥ k:
          <ul>
            <li>Subtract nums[left] from sum</li>
            <li>Move left pointer forward</li>
          </ul>
        </li>
        <li><strong>Add</strong> window length to count (all subarrays ending at right)</li>
        <li><strong>Return</strong> the total count</li>
      </ol>

      <h3>Complexity Analysis</h3>
      <table>
        <thead>
          <tr>
            <th>Time Complexity</th>
            <th>Space Complexity</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>O(n)</td>
            <td>O(1)</td>
          </tr>
        </tbody>
      </table>

      <p>
        <strong>Explanation:</strong> Each element is processed exactly twice (added once when window expands and removed once when window contracts), resulting in O(n) time complexity.
      </p>

      <h3>Implementation</h3>

      <div class="code-tabs">
        <div class="tab-buttons">
          <button
            class="tab-button active"
            onclick="openTab(event, 'cpp-optimal')"
          >
            C++
          </button>
          <button class="tab-button" onclick="openTab(event, 'java-optimal')">
            Java
          </button>
          <button class="tab-button" onclick="openTab(event, 'python-optimal')">
            Python
          </button>
        </div>

        <div id="cpp-optimal" class="tab-content active">
          <pre><code>
class Solution {
public:
    long long countSubarrays(vector&lt;int&gt;& nums, long long k) {
        long long count = 0;
        long long sum = 0;
        int left = 0;
        int n = nums.size();
        
        for(int right = 0; right &lt; n; right++) {
            sum += nums[right];
            
            // Shrink the window from left while condition is invalid
            while(sum * (right - left + 1) >= k) {
                sum -= nums[left];
                left++;
            }
            
            // All subarrays ending at 'right' with start >= left are valid
            count += (right - left + 1);
        }
        
        return count;
    }
};
                </code></pre>
        </div>

        <div id="java-optimal" class="tab-content">
          <pre><code>
class Solution {
    public long countSubarrays(int[] nums, long k) {
        long count = 0;
        long sum = 0;
        int left = 0;
        int n = nums.length;
        
        for(int right = 0; right &lt; n; right++) {
            sum += nums[right];
            
            // Shrink the window from left while condition is invalid
            while(sum * (right - left + 1) >= k) {
                sum -= nums[left];
                left++;
            }
            
            // All subarrays ending at 'right' with start >= left are valid
            count += (right - left + 1);
        }
        
        return count;
    }
}
                </code></pre>
        </div>

        <div id="python-optimal" class="tab-content">
          <pre><code>
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        count = 0
        current_sum = 0
        left = 0
        
        for right in range(len(nums)):
            current_sum += nums[right]
            
            # Shrink the window from left while condition is invalid
            while current_sum * (right - left + 1) >= k:
                current_sum -= nums[left]
                left += 1
                
            # All subarrays ending at 'right' with start >= left are valid
            count += (right - left + 1)
            
        return count
                </code></pre>
        </div>
      </div>

      <div class="callout tip">
        <strong>Why This Works:</strong> For each right pointer, we find the smallest left such that the window [left..right] has score &lt; k. All subarrays ending at right with start ≥ left are valid, and there are exactly (right - left + 1) of them.
      </div>

      <hr />

      <h2>Edge Cases and Special Considerations</h2>
      <p>
        When implementing solutions for this problem, consider these edge cases:
      </p>

      <h3>1. Single Element Arrays</h3>
      <pre><code><b>Input:</b> nums = [5], k = 10
<b>Output:</b> 1 (5 × 1 = 5 &lt; 10)

<b>Input:</b> nums = [10], k = 5
<b>Output:</b> 0 (10 × 1 = 10 ≥ 5)</code></pre>

      <h3>2. All Elements Equal</h3>
      <pre><code><b>Input:</b> nums = [2,2,2,2], k = 10
<b>Output:</b> 4
[2]×1=2, [2]×1=2, [2]×1=2, [2]×1=2
No subarrays of length ≥2 have score &lt; 10:
[2,2]×2=8, [2,2,2]×3=18, etc.</code></pre>

      <h3>3. Large k Values</h3>
      <pre><code><b>Input:</b> nums = [1,2,3,...,100000], k = 10<sup>15</sup>
<b>Output:</b> n*(n+1)/2 ≈ 5×10<sup>9</sup> (all possible subarrays)
Must handle large counts efficiently</code></pre>

      <h3>4. Minimum/Maximum Values</h3>
      <pre><code><b>Input:</b> nums = [1,1,1,...,1] (10<sup>5</sup> elements), k = 2
<b>Output:</b> 10<sup>5</sup> (only single-element subarrays qualify)</code></pre>

      <div class="callout warning">
        <strong>Important:</strong> Always test with the upper constraint limits (n=10⁵) to ensure your solution handles large inputs efficiently.
      </div>

      <hr />

      <h2>Comparison of Approaches</h2>
      <table>
        <thead>
          <tr>
            <th>Approach</th>
            <th>Time Complexity</th>
            <th>Space Complexity</th>
            <th>When to Use</th>
            <th>Pros</th>
            <th>Cons</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Brute Force</td>
            <td>O(n²)</td>
            <td>O(1)</td>
            <td>Small inputs (n &lt; 1000)</td>
            <td>Simple to implement</td>
            <td>Fails for large n</td>
          </tr>
          <tr>
            <td>Sliding Window</td>
            <td>O(n)</td>
            <td>O(1)</td>
            <td>All cases, especially large n</td>
            <td>Optimal for constraints</td>
            <td>Slightly more complex logic</td>
          </tr>
        </tbody>
      </table>

      <div class="callout tip">
        <strong>Interview Tip:</strong> When you see subarray problems with positive numbers and product/sum conditions, the sliding window technique should be your first thought. This pattern is common in coding interviews.
      </div>

      <hr />

      <h2>Frequently Asked Questions</h2>

      <div class="faq-section">
        <details>
          <summary>
            1. Why does the sliding window approach work for this problem?
          </summary>
          <p>
            The sliding window approach works because all numbers are positive. This means that expanding the window always increases the score (sum × length), and shrinking the window always decreases it. This monotonic property allows us to efficiently find valid windows by adjusting the left pointer.
          </p>
        </details>

        <details>
          <summary>
            2. Would this solution work if the array contained negative numbers?
          </summary>
          <p>
            No, the sliding window approach wouldn't work directly with negative numbers because expanding the window could potentially decrease the sum (and thus the score). For arrays with negative numbers, we would need a different approach like prefix sums with a hash map.
          </p>
        </details>

        <details>
          <summary>
            3. How does the count += (right - left + 1) work?
          </summary>
          <p>
            This counts all valid subarrays ending at the current right pointer. For a window [left..right], there are exactly (right - left + 1) subarrays ending at right: [left..right], [left+1..right], ..., [right..right].
          </p>
        </details>

        <details>
          <summary>
            4. What's the space complexity of the optimal solution?
          </summary>
          <p>
            The space complexity is O(1) because we only use a constant amount of additional space (for variables like sum, count, left, right) regardless of the input size.
          </p>
        </details>

        <details>
          <summary>
            5. Can this problem be solved using prefix sums?
          </summary>
          <p>
            While prefix sums could help calculate subarray sums quickly, they wouldn't directly help with the score calculation (sum × length) or the sliding window optimization. The sliding window approach is more suitable for this specific problem.
          </p>
        </details>

        <details>
          <summary>
            6. How would you modify the solution if the condition was ≤ k instead of &lt; k?
          </summary>
          <p>
            We would simply change the while loop condition from <code>>= k</code> to <code>> k</code>. This would make the window include subarrays with score equal to k in our count.
          </p>
        </details>

        <details>
          <summary>
            7. What's the best way to test this code?
          </summary>
          <p>
            Test with: single-element arrays, all elements equal, strictly increasing/decreasing arrays, minimum/maximum values, and the upper constraint limits. Also verify edge cases where k is very small or very large compared to array values.
          </p>
        </details>

        <details>
          <summary>
            8. Is there a mathematical formula to solve this without iteration?
          </summary>
          <p>
            No general formula exists because the solution depends on the specific values in the array. The sliding window approach is optimal for this problem with O(n) time complexity.
          </p>
        </details>

        <details>
          <summary>
            9. How does this problem relate to real-world applications?
          </summary>
          <p>
            Similar algorithms are used in data streaming applications where we need to monitor subsets of data that meet certain statistical criteria (like average × duration below a threshold). It's also useful in financial analysis for finding periods with certain performance metrics.
          </p>
        </details>

        <details>
          <summary>
            10. What similar problems should I practice to master this pattern?
          </summary>
          <p>
            Recommended problems: 209 (Minimum Size Subarray Sum), 713 (Subarray Product Less Than K), 904 (Fruit Into Baskets), 1004 (Max Consecutive Ones III), and 1658 (Minimum Operations to Reduce X to Zero). These all use variations of the sliding window technique.
          </p>
        </details>
      </div>

      <div class="callout">
        <strong>Final Thoughts:</strong> This problem beautifully demonstrates the power of the sliding window technique for optimizing subarray calculations. The key insight is recognizing that with positive numbers, window expansion and contraction have predictable effects on the score. Mastering this pattern will help you solve many array manipulation problems efficiently.
      </div>
    </main>

    <!-- Footer will be inserted by JavaScript -->
    <div id="footer"></div>

  </body>
</html>
    