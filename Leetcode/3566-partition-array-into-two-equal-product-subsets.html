<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3566 | Partition Array into Two Equal Product Subsets</title>
    <meta name="description"
        content="LeetCode 3566 solution: Efficient approaches to partition an array into two subsets with equal product, including prime factorization and bitmasking techniques.">
    <meta name="keywords"
        content="LeetCode 3566, leetcode 3566 Partition Array into Two Equal Product Subsets, Partition Array into Two Equal Product Subsets solution, Partition Array, Equal Product Subsets, Prime Factorization, Bitmasking, Subset Sum Problem, LeetCode Premium Problem, Competitive Programming, leetcode, leetcode problem of the day, leetcode contest question, leetcode medium question, leetcode daily question, Leetcode DSA interview question, SDE interview question">
    <meta name="author" content="Algopush">
    <link rel="canonical" href="https://algopush.com/Leetcode/3566-partition-array-into-two-equal-product-subsets.html">

    <!-- Favicon -->
    <link rel="icon" href="../components/favicon.png" type="image/x-icon">
    <link rel="apple-touch-icon" href="../components/favicon.png">

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="LeetCode 3566 | Partition Array into Two Equal Product Subsets">
    <meta property="og:description"
        content="LeetCode 3566 solution: Efficient approaches to partition an array into two subsets with equal product, including prime factorization and bitmasking techniques.">
    <meta property="og:image" content="https://algopush.com/Leetcode/Images/3566.png">
    <meta property="og:url"
        content="https://algopush.com/Leetcode/3566-partition-array-into-two-equal-product-subsets.html">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="LeetCode 3566 | Partition Array into Two Equal Product Subsets">
    <meta name="twitter:description"
        content="LeetCode 3566 solution: Efficient approaches to partition an array into two subsets with equal product, including prime factorization and bitmasking techniques.">
    <meta name="twitter:image" content="https://algopush.com/Leetcode/Images/3566.png">

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "TechArticle",
        "headline": "Partition Array into Two Equal Product Subsets Solution Guide",
        "url": "https://algopush.com/Leetcode/3566-partition-array-into-two-equal-product-subsets.html",
        "image": "https://algopush.com/Leetcode/Images/3566.png",
        "author": {
            "@type": "Organization",
            "name": "Algopush",
            "url": "https://algopush.com"
        },
        "datePublished": "2025-06-02",
        "publisher": {
            "@type": "Organization",
            "name": "Algopush",
            "logo": {
                "@type": "ImageObject",
                "url": "https://algopush.com/components/logo.png"
            }
        }
    }
    </script>

    <style>
        :root {
            --primary-color: #102c41;
            --secondary-color: #196391;
            --accent-color: #102c41;
            --meta-color: #db5305;
            --light-bg: #f5f9fc;
            --highlight-color: #f5f9fc;
            --text-color: black;
            --light-text: #7f8c8d;
            --border-radius: 6px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
            --callout-tip: #e8f8f5;
            --callout-note: #eaf2f8;
            --callout-warning: #fef5e7;
            --callout-danger: #ffebee;
            --callout-tip-border: #1abc9c;
            --callout-note-border: #3498db;
            --callout-warning-border: #f39c12;
            --callout-danger-border: #f44336;
        }

        /* Base Styles */
        body {
            margin: 0;
            padding: 0;
            font-family: "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background-color: var(--light-bg);
            color: var(--text-color);
            line-height: 1.7;
            font-size: 1.05rem;
        }

        /* Main Content Container */
        main {
            max-width: 920px;
            margin: 2rem auto;
            padding: 2rem;
            background: #fff;
            box-shadow: var(--box-shadow);
            border-radius: var(--border-radius);
        }

        /* Problem Visualization Image */
        .problem-visual {
            max-width: 100%;
            margin: 1.5rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            text-align: center;
        }

        .problem-visual img {
            max-width: 100%;
            height: auto;
            max-height: 400px;
            display: inline-block;
        }

        /* Typography */
        h1,
        h2,
        h3,
        h4 {
            color: var(--primary-color);
            font-weight: 600;
            margin-top: 1.8rem;
            margin-bottom: 1rem;
            line-height: 1.3;
        }

        h1 {
            font-size: 2rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.6rem;
            border-left: 4px solid var(--accent-color);
            padding-left: 0.8rem;
        }

        h3 {
            font-size: 1.3rem;
            color: var(--secondary-color);
        }

        a {
            color: var(--accent-color);
            text-decoration: none;
            transition: var(--transition);
        }

        a:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }

        hr {
            border: 0;
            height: 1px;
            background: #ddd;
        }

        /* Code Blocks */
        /* Code Blocks */
        pre {
            background: #f8f9fa;
            margin-top: 0.5rem;
            padding: 1.2rem;
            border-radius: var(--border-radius);
            overflow-x: auto;
            border-left: 4px solid var(--accent-color);
            font-size: 0.95rem;
            line-height: 1.5;
        }

        code {
            font-family: monospace;
            color: #2c3e50;
        }

        /* LeetCode-like Syntax Highlighting with Light Theme */
        .code-token-keyword {
            color: #007acc;
            /* LeetCode's blue for keywords */
        }

        .code-token-function {
            color: #795e26;
            /* LeetCode's function yellowish-brown */
        }

        .code-token-number {
            color: #098658;
            /* LeetCode's number green */
        }

        .code-token-string {
            color: #a31515;
            /* Typical red strings (LeetCode-like) */
        }

        .code-token-comment {
            color: #6a737d;
            font-style: italic;
        }

        /* Highlight Callouts */
        .highlight {
            background: var(--highlight-color);
            padding: 1rem;
            border-radius: var(--border-radius);
            margin: 1.5rem 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            padding: 0.8rem;
            text-align: center;
            border: 1px solid #ddd;
        }

        th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 500;
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        /* Code Container */
        .code-container {
            position: relative;
            margin: 1.5rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
        }

        .code-header {
            background: var(--primary-color);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }

        .code-filename {
            font-weight: 600;
        }

        .code-copy {
            background: white;
            color: var(--primary-color);
            border: none;
            padding: 0.25rem 0.75rem;
            border-radius: 3px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
        }

        .code-copy:hover {
            background: var(--highlight-color);
        }

        /* Tabs */
        .code-tabs {
            margin: 0.5rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
        }

        .tab-buttons {
            display: flex;
            background: #eaecee;
            border-bottom: 1px solid #ddd;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tab-button {
            padding: 0.7rem 1.2rem;
            background: transparent;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-color);
            transition: var(--transition);
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
        }

        .tab-button:hover:not(.active) {
            background: #d5dbdb;
        }

        .tab-content {
            display: none;
            background: white;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }


        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* FAQ Section */
        .faq-section {
            margin: 2rem 0;
        }

        .faq-section details {
            margin: 0.8rem 0;
            padding: 0.1rem;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            background: white;
            transition: var(--transition);
        }

        .faq-section details[open] {
            border-color: var(--accent-color);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            background: #f9f9f9;
        }

        .faq-section summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--primary-color);
            padding: 0.8rem;
            outline: none;
            transition: var(--transition);
        }

        .faq-section summary:hover {
            color: var(--accent-color);
            background: #f5f5f5;
        }

        .faq-section p {
            margin-top: 1rem;
            padding: 0 1rem 1rem;
        }

        /* Breadcrumb Navigation */
        .breadcrumb {
            padding: 0.8rem 1rem;
            background: linear-gradient(to right, #f5f5f5, white);
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
            font-size: 0.9rem;
        }

        .breadcrumb a {
            color: var(--secondary-color);
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        /* Problem Metadata */
        .problem-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1.5rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: var(--border-radius);
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .meta-item .label {
            font-weight: 600;
            color: var(--meta-color);
        }

        /* Callout Boxes */
        .callout {
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            border-radius: var(--border-radius);
            border-left: 4px solid;
        }

        .callout.tip {
            background-color: var(--callout-tip);
            border-color: var(--callout-tip-border);
        }

        .callout.note {
            background-color: var(--callout-note);
            border-color: var(--callout-note-border);
        }

        .callout.warning {
            background-color: var(--callout-warning);
            border-color: var(--callout-warning-border);
        }

        .callout.danger {
            background-color: var(--callout-danger);
            border-color: var(--callout-danger-border);
        }

        .callout strong {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            main {
                margin: 1rem;
                padding: 1.5rem;
            }

            h1 {
                font-size: 1.7rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            .problem-meta {
                flex-direction: column;
            }

            table {
                display: block;
                overflow-x: auto;
            }
        }

        @media (max-width: 480px) {
            main {
                padding: 1rem;
            }

            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.2rem;
            }

            pre {
                padding: 0.8rem;
                font-size: 0.85rem;
            }

            .tab-button {
                padding: 0.6rem;
                font-size: 0.9rem;
            }

            .code-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .code-copy {
                margin-top: 0.5rem;
            }
        }
    </style>
</head>

<body>
    <div id="header"></div>

    <main>
        <div class="breadcrumb">
            <a href="https://algopush.com">Home</a> &gt;
            <a href="https://algopush.com/Leetcode/leetcode.html">LeetCode</a> &gt;
            <span>3566. Partition Array into Two Equal Product Subsets</span>
        </div>

        <div class="problem-visual">
            <img src="https://algopush.com/Leetcode/Images/3566.png" alt="Partition Array Visualization">
        </div>

        <h1>3566: Partition Array into Two Equal Product Subsets</h1>

        <div class="problem-meta">
            <div class="meta-item">
                <span class="label">Difficulty:</span>
                <span class="value">Medium</span>
            </div>
            <div class="meta-item">
                <span class="label">Topics:</span>
                <span class="value">Arrays, Dynamic Programming, Bitmasking, Prime Factorization</span>
            </div>
            <div class="meta-item">
                <span class="label">Companies:</span>
                <span class="value">Google, Amazon, Microsoft</span>
            </div>
        </div>

        <h2>Problem Statement</h2>
        <p>Given an integer array nums containing distinct positive integers and an integer target, determine if you can
            partition nums into two non-empty disjoint subsets such that the product of the elements in each subset
            equals the target.</p>

        <h3>Example 1</h3>
        <pre><code>Input: nums = [3,1,6,8,4], target = 24
Output: true
Explanation: The subsets [3, 8] and [1, 6, 4] each have a product of 24.</code></pre>

        <h3>Example 2</h3>
        <pre><code>Input: nums = [2,5,3,7], target = 15
Output: false
Explanation: No possible partition exists where both subsets have product 15.</code></pre>

        <div class="callout note">
            <strong>Problem Link:</strong>
            <a href="https://leetcode.com/problems/partition-array-into-two-equal-product-subsets/" target="_blank">
                View on LeetCode ↗
            </a>
        </div>

        <hr>

        <h2>Approach 1: Prime Factorization with Bitmasking</h2>
        <p>This approach uses prime factorization to handle large products efficiently and bitmasking to explore all
            possible subsets.</p>

        <h3>Algorithm Steps</h3>
        <ol>
            <li>Factorize each number in the array and the target into their prime factors</li>
            <li>Check if the total product of all elements equals target squared</li>
            <li>Use bitmasking to iterate through all possible subsets</li>
            <li>For each subset, check if its prime factorization matches the target's</li>
        </ol>

        <div class="code-container">
            <div class="code-header">
                <span class="code-filename">Prime Factorization Solution</span>
                <button class="code-copy">Copy Code</button>
            </div>

            <div class="code-tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="cpp-prime">C++</button>
                    <button class="tab-button" data-tab="java-prime">Java</button>
                    <button class="tab-button" data-tab="python-prime">Python</button>
                </div>

                <!-- C++ Code -->
                <div class="tab-content active" id="cpp-prime-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">bool</span> <span class="code-token-function">checkEqualPartitions</span>(vector&lt;<span class="code-token-keyword">int</span>&gt;& nums, <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> target) {
        <span class="code-token-keyword">int</span> n = nums.size();
        vector&lt;<span class="code-token-keyword">int</span>&gt; primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
        <span class="code-token-keyword">int</span> nprimes = primes.size();

        vector&lt;vector&lt;<span class="code-token-keyword">int</span>&gt;&gt; fact(n, vector&lt;<span class="code-token-keyword">int</span>&gt;(nprimes, 0));
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; n; i++) {
            <span class="code-token-keyword">int</span> num = nums[i];
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
                <span class="code-token-keyword">int</span> p = primes[j];
                <span class="code-token-keyword">while</span> (num % p == 0) {
                    fact[i][j]++;
                    num /= p;
                }
            }
        }

        vector&lt;<span class="code-token-keyword">int</span>&gt; target_expo(nprimes, 0);
        <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> temp = target;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
            <span class="code-token-keyword">int</span> p = primes[j];
            <span class="code-token-keyword">while</span> (temp % p == 0) {
                target_expo[j]++;
                temp /= p;
            }
        }
        <span class="code-token-keyword">if</span> (temp != 1) {
            <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;
        }

        vector&lt;<span class="code-token-keyword">int</span>&gt; total_expo(nprimes, 0);
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; n; i++) {
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
                total_expo[j] += fact[i][j];
            }
        }
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
            <span class="code-token-keyword">if</span> (total_expo[j] != 2 * target_expo[j]) {
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;
            }
        }

        <span class="code-token-keyword">int</span> full_mask = (1 &lt;&lt; n);
        <span class="code-token-keyword">int</span> forbidden_mask = 0;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; n; i++) {
            <span class="code-token-keyword">if</span> (nums[i] &gt; target) {
                forbidden_mask |= (1 &lt;&lt; i);
            }
        }

        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> mask = 1; mask &lt; full_mask - 1; mask++) {
            <span class="code-token-keyword">if</span> (mask & forbidden_mask) {
                <span class="code-token-keyword">continue</span>;
            }

            vector&lt;<span class="code-token-keyword">int</span>&gt; cur_expo(nprimes, 0);
            <span class="code-token-keyword">bool</span> exceeded = <span class="code-token-keyword">false</span>;
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; n; i++) {
                <span class="code-token-keyword">if</span> (mask & (1 &lt;&lt; i)) {
                    <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
                        cur_expo[j] += fact[i][j];
                        <span class="code-token-keyword">if</span> (cur_expo[j] &gt; target_expo[j]) {
                            exceeded = <span class="code-token-keyword">true</span>;
                            <span class="code-token-keyword">break</span>;
                        }
                    }
                    <span class="code-token-keyword">if</span> (exceeded) <span class="code-token-keyword">break</span>;
                }
            }
            <span class="code-token-keyword">if</span> (exceeded) <span class="code-token-keyword">continue</span>;

            <span class="code-token-keyword">bool</span> valid = <span class="code-token-keyword">true</span>;
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
                <span class="code-token-keyword">if</span> (cur_expo[j] != target_expo[j]) {
                    valid = <span class="code-token-keyword">false</span>;
                    <span class="code-token-keyword">break</span>;
                }
            }
            <span class="code-token-keyword">if</span> (valid) {
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">true</span>;
            }
        }

        <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;
    }
};</code></pre>
                </div>

                <!-- Java Code -->
                <div class="tab-content" id="java-prime-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">boolean</span> <span class="code-token-function">checkEqualPartitions</span>(<span class="code-token-keyword">int</span>[] nums, <span class="code-token-keyword">long</span> target) {
        <span class="code-token-keyword">int</span> n = nums.length;
        <span class="code-token-keyword">int</span>[] primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
        <span class="code-token-keyword">int</span> nprimes = primes.length;

        <span class="code-token-keyword">int</span>[][] fact = <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[n][nprimes];
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; n; i++) {
            <span class="code-token-keyword">int</span> num = nums[i];
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
                <span class="code-token-keyword">int</span> p = primes[j];
                <span class="code-token-keyword">while</span> (num % p == 0) {
                    fact[i][j]++;
                    num /= p;
                }
            }
        }

        <span class="code-token-keyword">int</span>[] target_expo = <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[nprimes];
        <span class="code-token-keyword">long</span> temp = target;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
            <span class="code-token-keyword">int</span> p = primes[j];
            <span class="code-token-keyword">while</span> (temp % p == 0) {
                target_expo[j]++;
                temp /= p;
            }
        }
        <span class="code-token-keyword">if</span> (temp != 1) {
            <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;
        }

        <span class="code-token-keyword">int</span>[] total_expo = <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[nprimes];
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; n; i++) {
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
                total_expo[j] += fact[i][j];
            }
        }
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
            <span class="code-token-keyword">if</span> (total_expo[j] != 2 * target_expo[j]) {
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;
            }
        }

        <span class="code-token-keyword">int</span> full_mask = (1 &lt;&lt; n);
        <span class="code-token-keyword">int</span> forbidden_mask = 0;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; n; i++) {
            <span class="code-token-keyword">if</span> (nums[i] &gt; target) {
                forbidden_mask |= (1 &lt;&lt; i);
            }
        }

        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> mask = 1; mask &lt; full_mask - 1; mask++) {
            <span class="code-token-keyword">if</span> ((mask & forbidden_mask) != 0) {
                <span class="code-token-keyword">continue</span>;
            }

            <span class="code-token-keyword">int</span>[] cur_expo = <span class="code-token-keyword">new</span> <span class="code-token-keyword">int</span>[nprimes];
            <span class="code-token-keyword">boolean</span> exceeded = <span class="code-token-keyword">false</span>;
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 0; i &lt; n; i++) {
                <span class="code-token-keyword">if</span> ((mask & (1 &lt;&lt; i)) != 0) {
                    <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
                        cur_expo[j] += fact[i][j];
                        <span class="code-token-keyword">if</span> (cur_expo[j] &gt; target_expo[j]) {
                            exceeded = <span class="code-token-keyword">true</span>;
                            <span class="code-token-keyword">break</span>;
                        }
                    }
                    <span class="code-token-keyword">if</span> (exceeded) <span class="code-token-keyword">break</span>;
                }
            }
            <span class="code-token-keyword">if</span> (exceeded) <span class="code-token-keyword">continue</span>;

            <span class="code-token-keyword">boolean</span> valid = <span class="code-token-keyword">true</span>;
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> j = 0; j &lt; nprimes; j++) {
                <span class="code-token-keyword">if</span> (cur_expo[j] != target_expo[j]) {
                    valid = <span class="code-token-keyword">false</span>;
                    <span class="code-token-keyword">break</span>;
                }
            }
            <span class="code-token-keyword">if</span> (valid) {
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">true</span>;
            }
        }

        <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;
    }
}</code></pre>
                </div>

                <!-- Python Code -->
                <div class="tab-content" id="python-prime-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">checkEqualPartitions</span>(self, nums: List[<span class="code-token-keyword">int</span>], target: <span class="code-token-keyword">int</span>) -> <span class="code-token-keyword">bool</span>:
        n = <span class="code-token-keyword">len</span>(nums)
        primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
        nprimes = <span class="code-token-keyword">len</span>(primes)

        fact = [[0]*nprimes <span class="code-token-keyword">for</span> _ <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(n)]
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(n):
            num = nums[i]
            <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(nprimes):
                p = primes[j]
                <span class="code-token-keyword">while</span> num % p == 0:
                    fact[i][j] += 1
                    num = num // p

        target_expo = [0]*nprimes
        temp = target
        <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(nprimes):
            p = primes[j]
            <span class="code-token-keyword">while</span> temp % p == 0:
                target_expo[j] += 1
                temp = temp // p
        <span class="code-token-keyword">if</span> temp != 1:
            <span class="code-token-keyword">return</span> <span class="code-token-keyword">False</span>

        total_expo = [0]*nprimes
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(n):
            <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(nprimes):
                total_expo[j] += fact[i][j]
        <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(nprimes):
            <span class="code-token-keyword">if</span> total_expo[j] != 2 * target_expo[j]:
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">False</span>

        full_mask = 1 &lt;&lt; n
        forbidden_mask = 0
        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(n):
            <span class="code-token-keyword">if</span> nums[i] > target:
                forbidden_mask |= (1 &lt;&lt; i)

        <span class="code-token-keyword">for</span> mask <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(1, full_mask - 1):
            <span class="code-token-keyword">if</span> mask & forbidden_mask:
                <span class="code-token-keyword">continue</span>

            cur_expo = [0]*nprimes
            exceeded = <span class="code-token-keyword">False</span>
            <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(n):
                <span class="code-token-keyword">if</span> mask & (1 &lt;&lt; i):
                    <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(nprimes):
                        cur_expo[j] += fact[i][j]
                        <span class="code-token-keyword">if</span> cur_expo[j] > target_expo[j]:
                            exceeded = <span class="code-token-keyword">True</span>
                            <span class="code-token-keyword">break</span>
                    <span class="code-token-keyword">if</span> exceeded:
                        <span class="code-token-keyword">break</span>
            <span class="code-token-keyword">if</span> exceeded:
                <span class="code-token-keyword">continue</span>

            valid = <span class="code-token-keyword">True</span>
            <span class="code-token-keyword">for</span> j <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(nprimes):
                <span class="code-token-keyword">if</span> cur_expo[j] != target_expo[j]:
                    valid = <span class="code-token-keyword">False</span>
                    <span class="code-token-keyword">break</span>
            <span class="code-token-keyword">if</span> valid:
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">True</span>

        <span class="code-token-keyword">return</span> <span class="code-token-keyword">False</span></code></pre>
                </div>
            </div>

            <div class="callout tip">
                <strong>Optimization:</strong> Prime factorization allows handling large products without overflow, and
                bitmasking efficiently explores all subsets.
            </div>
        </div>

        <hr>

        <h2>Approach 2: Backtracking with Pruning</h2>
        <p>This approach uses backtracking with pruning to find a subset with product equal to target.</p>

        <div class="code-container">
            <div class="code-header">
                <span class="code-filename">Backtracking Solution</span>
                <button class="code-copy">Copy Code</button>
            </div>

            <div class="code-tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="cpp-backtrack">C++</button>
                    <button class="tab-button" data-tab="java-backtrack">Java</button>
                    <button class="tab-button" data-tab="python-backtrack">Python</button>
                </div>

                <!-- C++ Code -->
                <div class="tab-content active" id="cpp-backtrack-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">bool</span> <span class="code-token-function">checkEqualPartitions</span>(vector&lt;<span class="code-token-keyword">int</span>&gt;& nums, <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> target) {
        <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> total = 1;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : nums) {
            total *= num;
            <span class="code-token-keyword">if</span> (total > target * target) <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;
        }
        <span class="code-token-keyword">if</span> (total != target * target) <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;

        <span class="code-token-keyword">return</span> <span class="code-token-function">backtrack</span>(nums, 0, 1, target);
    }

    <span class="code-token-keyword">bool</span> <span class="code-token-function">backtrack</span>(vector&lt;<span class="code-token-keyword">int</span>&gt;& nums, <span class="code-token-keyword">int</span> start, <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> product, <span class="code-token-keyword">long</span> <span class="code-token-keyword">long</span> target) {
        <span class="code-token-keyword">if</span> (product == target) <span class="code-token-keyword">return</span> <span class="code-token-keyword">true</span>;
        <span class="code-token-keyword">if</span> (product > target || start >= nums.size()) <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;

        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = start; i &lt; nums.size(); i++) {
            <span class="code-token-keyword">if</span> (<span class="code-token-function">backtrack</span>(nums, i + 1, product * nums[i], target)) {
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">true</span>;
            }
        }
        <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;
    }
};</code></pre>
                </div>

                <!-- Java Code -->
                <div class="tab-content" id="java-backtrack-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">boolean</span> <span class="code-token-function">checkEqualPartitions</span>(<span class="code-token-keyword">int</span>[] nums, <span class="code-token-keyword">long</span> target) {
        <span class="code-token-keyword">long</span> total = 1;
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> num : nums) {
            total *= num;
            <span class="code-token-keyword">if</span> (total > target * target) <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;
        }
        <span class="code-token-keyword">if</span> (total != target * target) <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;

        <span class="code-token-keyword">return</span> <span class="code-token-function">backtrack</span>(nums, 0, 1, target);
    }

    <span class="code-token-keyword">private</span> <span class="code-token-keyword">boolean</span> <span class="code-token-function">backtrack</span>(<span class="code-token-keyword">int</span>[] nums, <span class="code-token-keyword">int</span> start, <span class="code-token-keyword">long</span> product, <span class="code-token-keyword">long</span> target) {
        <span class="code-token-keyword">if</span> (product == target) <span class="code-token-keyword">return</span> <span class="code-token-keyword">true</span>;
        <span class="code-token-keyword">if</span> (product > target || start >= nums.length) <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;

        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = start; i &lt; nums.length; i++) {
            <span class="code-token-keyword">if</span> (<span class="code-token-function">backtrack</span>(nums, i + 1, product * nums[i], target)) {
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">true</span>;
            }
        }
        <span class="code-token-keyword">return</span> <span class="code-token-keyword">false</span>;
    }
}</code></pre>
                </div>

                <!-- Python Code -->
                <div class="tab-content" id="python-backtrack-tab">
                    <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">checkEqualPartitions</span>(self, nums: List[<span class="code-token-keyword">int</span>], target: <span class="code-token-keyword">int</span>) -> <span class="code-token-keyword">bool</span>:
        total = 1
        <span class="code-token-keyword">for</span> num <span class="code-token-keyword">in</span> nums:
            total *= num
            <span class="code-token-keyword">if</span> total > target * target:
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">False</span>
        <span class="code-token-keyword">if</span> total != target * target:
            <span class="code-token-keyword">return</span> <span class="code-token-keyword">False</span>

        <span class="code-token-keyword">return</span> self.<span class="code-token-function">backtrack</span>(nums, 0, 1, target)

    <span class="code-token-keyword">def</span> <span class="code-token-function">backtrack</span>(self, nums: List[<span class="code-token-keyword">int</span>], start: <span class="code-token-keyword">int</span>, product: <span class="code-token-keyword">int</span>, target: <span class="code-token-keyword">int</span>) -> <span class="code-token-keyword">bool</span>:
        <span class="code-token-keyword">if</span> product == target:
            <span class="code-token-keyword">return</span> <span class="code-token-keyword">True</span>
        <span class="code-token-keyword">if</span> product > target <span class="code-token-keyword">or</span> start >= <span class="code-token-keyword">len</span>(nums):
            <span class="code-token-keyword">return</span> <span class="code-token-keyword">False</span>

        <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> <span class="code-token-keyword">range</span>(start, <span class="code-token-keyword">len</span>(nums)):
            <span class="code-token-keyword">if</span> self.<span class="code-token-function">backtrack</span>(nums, i + 1, product * nums[i], target):
                <span class="code-token-keyword">return</span> <span class="code-token-keyword">True</span>
        <span class="code-token-keyword">return</span> <span class="code-token-keyword">False</span></code></pre>
                </div>
            </div>

            <div class="callout warning">
                <strong>Note:</strong>
                <ul>
                    <li>Backtracking approach may be too slow for larger inputs (n > 20) due to exponential time
                        complexity.</li>
                    <li>Due to there exponential time complexity, this code will cause Run Time Error.</li>
                </ul>
            </div>
        </div>

        <hr>

        <h2>Approach Comparison</h2>
        <table>
            <thead>
                <tr>
                    <th>Approach</th>
                    <th>Time</th>
                    <th>Space</th>
                    <th>Readability</th>
                    <th>Optimal</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Prime Factorization</td>
                    <td>O(n * 2^n)</td>
                    <td>O(n)</td>
                    <td>Moderate</td>
                    <td>✅</td>
                </tr>
                <tr>
                    <td>Backtracking</td>
                    <td>O(2^n)</td>
                    <td>O(n)</td>
                    <td>Simple</td>
                    <td>❌</td>
                </tr>
            </tbody>
        </table>

        <div class="callout tip">
            <strong>Recommendation:</strong> The prime factorization approach is more efficient for handling large
            products and constraints.
        </div>

        <hr>

        <h2>Edge Cases</h2>
        <h3>1. Single Element Array</h3>
        <pre><code>Input: nums = [5], target = 5 → Output: false (Need two non-empty subsets)</code></pre>

        <h3>2. All Elements Equal to Target</h3>
        <pre><code>Input: nums = [2,2,2], target = 2 → Output: true ([2] and [2,2])</code></pre>

        <h3>3. Large Target Value</h3>
        <pre><code>Input: nums = [1,2,3,4,5,6,7,8,9,10], target = 3628800 → Output: true</code></pre>

        <div class="callout warning">
            <strong>Testing Tip:</strong> Always test with arrays containing 1 and the target value itself.
        </div>

        <hr>

        <h2>Frequently Asked Questions</h2>
        <div class="faq-section">
            <details>
                <summary>Why use prime factorization?</summary>
                <p>Prime factorization helps handle large products without overflow and allows comparison of exponents
                    rather than actual products.</p>
            </details>

            <details>
                <summary>How does bitmasking help in this problem?</summary>
                <p>Bitmasking provides an efficient way to represent and iterate through all possible subsets of the
                    array.</p>
            </details>

            <details>
                <summary>What's the time complexity of the prime factorization approach?</summary>
                <p>O(n * 2^n) in the worst case, but with pruning it's often much faster.</p>
            </details>

            <details>
                <summary>Can we use dynamic programming for this problem?</summary>
                <p>Yes, but it would require tracking products which could be very large and impractical for the given
                    constraints.</p>
            </details>

            <details>
                <summary>How to handle duplicate elements?</summary>
                <p>The problem states all elements are distinct, so we don't need to handle duplicates.</p>
            </details>

            <details>
                <summary>What if the target is 1?</summary>
                <p>We need to find two subsets whose product is 1, which means one subset must contain only 1s.</p>
            </details>

            <details>
                <summary>Why check if total product equals target squared?</summary>
                <p>Because if we partition into two subsets with product target each, their combined product must be
                    target × target.</p>
            </details>

            <details>
                <summary>How to optimize further?</summary>
                <p>We can sort the array in descending order to try larger elements first and prune more branches.</p>
            </details>

            <details>
                <summary>What's the maximum n this can handle?</summary>
                <p>With n=12, the bitmask approach is feasible (2^12 = 4096 subsets to check).</p>
            </details>

            <details>
                <summary>Can this be extended to k partitions?</summary>
                <p>Yes, but would require more complex tracking of multiple subset products.</p>
            </details>
        </div>

        <div class="callout">
            <strong>Final Recommendation:</strong> The prime factorization with bitmasking approach provides the best
            balance between efficiency and correctness for this problem.
        </div>
    </main>

    <div id="footer"></div>

    <script>
        // Tab functionality with improved mobile support
        document.addEventListener('DOMContentLoaded', function () {
            // Initialize tabs
            document.querySelectorAll('.code-tabs').forEach(container => {
                const tabButtons = container.querySelectorAll('.tab-button');
                const tabContents = container.querySelectorAll('.tab-content');

                // Set first tab as active by default if none are active
                if (!container.querySelector('.tab-button.active')) {
                    tabButtons[0]?.classList.add('active');
                    tabContents[0]?.classList.add('active');
                }

                // Add click handlers
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const tabName = button.getAttribute('data-tab');

                        // Update active tab button
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');

                        // Update active tab content
                        tabContents.forEach(content => content.classList.remove('active'));
                        container.querySelector(`#${tabName}-tab`).classList.add('active');
                    });
                });
            });

            // Copy button functionality
            document.querySelectorAll('.code-copy').forEach(button => {
                button.addEventListener('click', () => {
                    const activeTab = button.closest('.code-container').querySelector('.tab-content.active');
                    const code = activeTab.querySelector('code').innerText;
                    navigator.clipboard.writeText(code).then(() => {
                        const originalText = button.textContent;
                        button.textContent = 'Copied!';
                        setTimeout(() => button.textContent = originalText, 2000);
                    });
                });
            });

            // FAQ highlight when opened
            document.querySelectorAll('.faq-section details').forEach(detail => {
                detail.addEventListener('toggle', () => {
                    if (detail.open) {
                        detail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
            });

            // Load header and footer
            fetch("../components/header.html")
                .then((response) => response.text())
                .then((data) => {
                    document.getElementById("header").innerHTML = data;
                });

            fetch("../components/footer.html")
                .then((response) => response.text())
                .then((data) => {
                    document.getElementById("footer").innerHTML = data;
                });
        });
    </script>
</body>

</html>