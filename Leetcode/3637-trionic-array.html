<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LeetCode 3637 | Trionic Array I</title>
  <meta name="description" content="Learn how to solve the Trionic Array problem with multiple approaches. Detailed explanations of brute force and optimal O(n) solutions." />
  <meta name="keywords" content="3637. Trionic Array I, Trionic Array I, LeetCode 3637, Trionic Array, Array manipulation, Three segments, Strictly increasing, Strictly decreasing, Algorithm solution, Coding interview, algopush, Algorithm, Programming, Coding Interview, LeetCode Easy Problem, Competitive Programming, leetcode, leetcode problem of the day, leetcode contest question, leetcode easy question" />
  <meta name="author" content="Algopush" />
  <link rel="canonical" href="https://algopush.com/Leetcode/3637-trionic-array.html">

  <!-- Favicon -->
  <link rel="icon" href="../components/favicon.png" type="image/x-icon">
  <link rel="apple-touch-icon" href="../components/favicon.png">

  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="LeetCode 3637: Trionic Array I">
  <meta property="og:description" content="Learn multiple approaches to solve the Trionic Array problem. Brute force and optimal O(n) solutions with detailed explanations and code implementations.">
  <meta property="og:image" content="https://algopush.com/Leetcode/Images/3637.png">
  <meta property="og:url" content="https://algopush.com/Leetcode/3637-trionic-array.html">
  <meta property="og:type" content="article">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="LeetCode 3637: Trionic Array I">
  <meta name="twitter:description" content="Solve the Trionic Array problem with efficient O(n) solution. Code examples in C++, Java, and Python.">
  <meta name="twitter:image" content="https://algopush.com/Leetcode/Images/3637.png">

  <!-- Structured Data for SEO -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "Trionic Array I",
      "url": "https://algopush.com/Leetcode/3637-trionic-array.html",
      "image": "https://algopush.com/Leetcode/Images/3637.png",
      "author": {
        "@type": "Organization",
        "name": "Algopush",
        "url": "https://algopush.com"
      },
      "datePublished": "2025-08-03",
      "dateModified": "2025-08-03",
      "publisher": {
        "@type": "Organization",
        "name": "Algopush",
        "logo": {
          "@type": "ImageObject",
          "url": "https://algopush.com/components/logo.png"
        }
      },
      "founder": {
        "@type": "Person",
        "name": "Piyush Kumar",
        "jobTitle": "Founder",
        "url": "https://algopush.com/about"
      },
      "foundingDate": "2025",
      "description": "Algopush provides comprehensive algorithm solutions and explanations for coding interview preparation."
    }
  </script>

  <style>
    /* CSS styles identical to previous posts */
    :root {
      --primary-color: #102c41;
      --secondary-color: #196391;
      --accent-color: #102c41;
      --meta-color: #db5305;
      --light-bg: #f5f9fc;
      --highlight-color: #f5f9fc;
      --text-color: black;
      --light-text: #7f8c8d;
      --border-radius: 6px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
      --callout-tip: #e8f8f5;
      --callout-note: #eaf2f8;
      --callout-warning: #fef5e7;
      --callout-danger: #ffebee;
      --callout-tip-border: #1abc9c;
      --callout-note-border: #3498db;
      --callout-warning-border: #f39c12;
      --callout-danger-border: #f44336;
    }

    /* Base Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background-color: var(--light-bg);
      color: var(--text-color);
      line-height: 1.7;
      font-size: 1.05rem;
    }

    /* Main Content Container */
    main {
      max-width: 920px;
      margin: 2rem auto;
      padding: 2rem;
      background: #fff;
      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius);
    }

    /* Problem Visualization Image */
    .problem-visual {
      max-width: 100%;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
      text-align: center;
    }

    .problem-visual img {
      max-width: 100%;
      height: auto;
      max-height: 400px;
      display: inline-block;
    }

    /* Typography */
    h1, h2, h3, h4 {
      color: var(--primary-color);
      font-weight: 600;
      margin-top: 1.5rem;
      margin-bottom: 0.8rem;
      line-height: 1.3;
    }

    h1 {
      font-size: 2rem;
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 0.5rem;
    }

    h2 {
      font-size: 1.6rem;
      border-left: 4px solid var(--accent-color);
      padding-left: 0.8rem;
      margin-top: 2.5rem;
    }

    h3 {
      font-size: 1.3rem;
      color: var(--secondary-color);
      margin-top: 1.8rem;
    }

    a {
      color: var(--accent-color);
      text-decoration: none;
      transition: var(--transition);
    }

    a:hover {
      color: var(--primary-color);
      text-decoration: underline;
    }

    hr {
      border: 0;
      height: 1px;
      background: #ddd;
      margin: 2rem 0;
    }

    /* Code Blocks */
    pre {
      background: #f8f9fa;
      padding: 1.2rem;
      border-radius: var(--border-radius);
      overflow-x: auto;
      border-left: 4px solid var(--accent-color);
      font-size: 0.95rem;
      line-height: 1.5;
      margin: 1rem 0;
    }

    code {
      font-family: monospace;
      color: #2c3e50;
    }

    .highlight {
      background: var(--highlight-color);
      padding: 1rem;
      border-radius: var(--border-radius);
      margin: 1.5rem 0;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    th, td {
      padding: 0.8rem;
      text-align: center;
      border: 1px solid #ddd;
    }

    th {
      background-color: var(--primary-color);
      color: white;
      font-weight: 500;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    /* Code Container */
    .code-container {
      position: relative;
      margin: 1rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    .code-header {
      background: var(--primary-color);
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: white;
    }

    .code-filename {
      font-weight: 600;
    }

    .code-copy {
      background: white;
      color: var(--primary-color);
      border: none;
      padding: 0.25rem 0.75rem;
      border-radius: 3px;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 500;
    }

    .code-copy:hover {
      background: var(--highlight-color);
    }

    /* Code Syntax Highlighting */
    .code-token-keyword {
      color: #d73a49;
    }

    .code-token-function {
      color: #6f42c1;
    }

    .code-token-comment {
      color: #6a737d;
      font-style: italic;
    }

    .code-token-string {
      color: #032f62;
    }

    .code-token-number {
      color: #005cc5;
    }

    /* Tabs */
    .code-tabs {
      margin: 0.5rem 0;
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    .tab-buttons {
      display: flex;
      background: #eaecee;
      border-bottom: 1px solid #ddd;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .tab-button {
      padding: 0.7rem 1.2rem;
      background: transparent;
      border: none;
      cursor: pointer;
      font-weight: 500;
      color: var(--text-color);
      transition: var(--transition);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .tab-button.active {
      background: var(--primary-color);
      color: white;
    }

    .tab-button:hover:not(.active) {
      background: #d5dbdb;
    }

    .tab-content {
      display: none;
      background: white;
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    /* FAQ Section */
    .faq-section {
      margin: 2rem 0;
    }

    .faq-section details {
      margin: 0.8rem 0;
      padding: 0.1rem;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      background: white;
      transition: var(--transition);
    }

    .faq-section details[open] {
      border-color: var(--accent-color);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      background: #f9f9f9;
    }

    .faq-section summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--primary-color);
      padding: 0.8rem;
      outline: none;
      transition: var(--transition);
    }

    .faq-section summary:hover {
      color: var(--accent-color);
      background: #f5f5f5;
    }

    .faq-section p {
      margin-top: 1rem;
      padding: 0 1rem 1rem;
    }

    /* Breadcrumb Navigation */
    .breadcrumb {
      padding: 0.8rem 1rem;
      background: linear-gradient(to right, #f5f5f5, white);
      border-radius: var(--border-radius);
      margin-bottom: 2rem;
      font-size: 0.9rem;
    }

    .breadcrumb a {
      color: var(--secondary-color);
    }

    .breadcrumb a:hover {
      text-decoration: underline;
    }

    /* Problem Metadata */
    .problem-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin: 1.5rem 0;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: var(--border-radius);
    }

    .meta-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .meta-item .label {
      font-weight: 600;
      color: var(--meta-color);
    }

    /* Callout Boxes */
    .callout {
      padding: 1rem 1.5rem;
      margin: 1.5rem 0;
      border-radius: var(--border-radius);
      border-left: 4px solid;
    }

    .callout.tip {
      background-color: var(--callout-tip);
      border-color: var(--callout-tip-border);
    }

    .callout.note {
      background-color: var(--callout-note);
      border-color: var(--callout-note-border);
    }

    .callout.warning {
      background-color: var(--callout-warning);
      border-color: var(--callout-warning-border);
    }

    .callout.danger {
      background-color: var(--callout-danger);
      border-color: var(--callout-danger-border);
    }

    .callout strong {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }

    /* Visualization Container */
    .visual-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin: 2rem 0;
    }
    
    .visual-item {
      flex: 1;
      min-width: 300px;
      padding: 1rem;
      border-radius: var(--border-radius);
      background: #f8f9fa;
      box-shadow: var(--box-shadow);
    }
    
    .visual-item h4 {
      color: var(--secondary-color);
      margin-top: 0;
      border-bottom: 1px solid #ddd;
      padding-bottom: 0.5rem;
    }

    .grid-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }
    
    .grid-item {
      padding: 1rem;
      text-align: center;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      background: white;
      font-weight: bold;
    }
    
    @keyframes pulse {
      0% { background-color: #e6f7ff; }
      50% { background-color: #b3e0ff; }
      100% { background-color: #e6f7ff; }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      main {
        margin: 1rem;
        padding: 1.5rem;
      }

      h1 {
        font-size: 1.7rem;
      }

      h2 {
        font-size: 1.4rem;
      }

      .problem-meta {
        flex-direction: column;
      }

      table {
        display: block;
        overflow-x: auto;
      }
      
      .visual-item {
        min-width: 100%;
      }
      
      .grid-container {
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      }
    }

    @media (max-width: 480px) {
      main {
        padding: 1rem;
      }

      h1 {
        font-size: 1.5rem;
      }

      h2 {
        font-size: 1.2rem;
      }

      pre {
        padding: 0.8rem;
        font-size: 0.85rem;
      }

      .tab-button {
        padding: 0.6rem;
        font-size: 0.9rem;
      }

      .code-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .code-copy {
        margin-top: 0.5rem;
      }
    }
  </style>
</head>

<body>
  <div id="header"></div>

  <main>
    <div class="breadcrumb">
      <a href="https://algopush.com">Home</a> &gt;
      <a href="https://algopush.com/Leetcode/leetcode.html">LeetCode</a> &gt;
      <span>3637. Trionic Array I</span>
    </div>

    <div class="problem-visual">
      <img src="https://algopush.com/Leetcode/Images/3637.png" alt="Trionic Array visualization" loading="lazy">
    </div>

    <h1>3637: Trionic Array I</h1>

    <div class="problem-meta">
      <div class="meta-item">
        <span class="label">Difficulty:</span>
        <span class="value">Easy</span>
      </div>
      <div class="meta-item">
        <span class="label">Topics:</span>
        <span class="value">Array, Pattern Recognition</span>
      </div>
      <div class="meta-item">
        <span class="label">Companies:</span>
        <span class="value">Google, Amazon, Bloomberg</span>
      </div>
    </div>

    <div class="callout tip">
      <strong>Pro Tip:</strong> When solving array pattern problems, visualize the array segments and their relationships. Drawing diagrams can help clarify the problem requirements.
    </div>

    <h2>Problem Statement</h2>
    <p>Given an integer array <code>nums</code> of length <code>n</code>, determine if it is a <strong>trionic array</strong>.</p>
    
    <p>An array is trionic if there exist indices <code>p</code> and <code>q</code> such that:</p>
    <ul>
      <li><code>0 &lt; p &lt; q &lt; n - 1</code> (all indices are valid and segments have at least 2 elements)</li>
      <li>The segment <code>nums[0...p]</code> is <strong>strictly increasing</strong></li>
      <li>The segment <code>nums[p...q]</code> is <strong>strictly decreasing</strong></li>
      <li>The segment <code>nums[q...n-1]</code> is <strong>strictly increasing</strong></li>
    </ul>
    
    <p>Return <code>true</code> if the array is trionic, otherwise return <code>false</code>.</p>

    <div class="visual-container">
      <div class="visual-item">
        <h4>Example 1</h4>
        <p><strong>Input:</strong> nums = [1,3,5,4,2,6]</p>
        <p><strong>Output:</strong> true</p>
        <p><strong>Explanation:</strong> 
          With p=2 (value 5) and q=4 (value 2):
          <ul>
            <li>[1,3,5] → strictly increasing</li>
            <li>[5,4,2] → strictly decreasing</li>
            <li>[2,6] → strictly increasing</li>
          </ul>
        </p>
      </div>
      
      <div class="visual-item">
        <h4>Example 2</h4>
        <p><strong>Input:</strong> nums = [2,1,3]</p>
        <p><strong>Output:</strong> false</p>
        <p><strong>Explanation:</strong> 
          There is no way to split the array into three segments that meet the criteria. The array is too short to have valid p and q indices.
        </p>
      </div>
      
      <div class="visual-item">
        <h4>Example 3</h4>
        <p><strong>Input:</strong> nums = [1,2,3,4,3,2,1,2,3]</p>
        <p><strong>Output:</strong> true</p>
        <p><strong>Explanation:</strong> 
          With p=3 (value 4) and q=6 (value 1):
          <ul>
            <li>[1,2,3,4] → strictly increasing</li>
            <li>[4,3,2,1] → strictly decreasing</li>
            <li>[1,2,3] → strictly increasing</li>
          </ul>
        </p>
      </div>
    </div>

    <div class="callout note">
      <strong>Problem Link:</strong>
      <a href="https://leetcode.com/problems/trionic-array-i/" target="_blank" rel="noopener noreferrer">
        View on LeetCode ↗
      </a>
    </div>

    <hr />

    <h2>Key Insight</h2>
    <p>The solution relies on identifying the characteristic "mountain" pattern in the array:</p>
    <ol>
      <li>The array starts by strictly increasing to a peak (at index p)</li>
      <li>Then strictly decreases to a valley (at index q)</li>
      <li>Finally strictly increases again to the end</li>
    </ol>
    
    <div class="callout warning">
      <strong>Important:</strong> The constraints require that each segment has at least 2 elements (0 &lt; p &lt; q &lt; n-1). This means the array must have at least 4 elements (since p and q need at least one element before and after).
    </div>

    <h2>Brute Force Approach (Check All Possible p and q)</h2>
    <p>This approach checks all possible combinations of p and q indices:</p>
    
    <h3>Algorithm Steps</h3>
    <ol>
      <li>Iterate through all possible p indices (from 1 to n-3)</li>
      <li>For each p, iterate through all possible q indices (from p+1 to n-2)</li>
      <li>For each (p, q) pair:
        <ul>
          <li>Check if [0, p] is strictly increasing</li>
          <li>Check if [p, q] is strictly decreasing</li>
          <li>Check if [q, n-1] is strictly increasing</li>
        </ul>
      </li>
      <li>If any combination satisfies all three conditions, return true</li>
      <li>If no combination works, return false</li>
    </ol>
    
    <h3>Complexity Analysis</h3>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>O(n³)</td>
          <td>O(1)</td>
        </tr>
      </tbody>
    </table>
    <p>This solution becomes inefficient for larger arrays (n ≈ 100) as it performs up to 100*100*100 = 1,000,000 operations in worst case.</p>

    <div class="code-container">
      <div class="code-header">
        <span class="code-filename">Brute Force Solution</span>
        <button class="code-copy">Copy Code</button>
      </div>
      <div class="code-tabs">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="cpp-brute">C++</button>
          <button class="tab-button" data-tab="java-brute">Java</button>
          <button class="tab-button" data-tab="python-brute">Python</button>
        </div>

        <!-- C++ Code -->
        <div class="tab-content active" id="cpp-brute-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">bool</span> <span class="code-token-function">isTrionic</span>(vector<<span class="code-token-keyword">int</span>>& nums) {
        <span class="code-token-keyword">int</span> n = nums.size();
        <span class="code-token-keyword">if</span> (n < 4) <span class="code-token-keyword">return</span> false;
        
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> p = 1; p <= n-3; p++) {
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> q = p+1; q <= n-2; q++) {
                <span class="code-token-comment">// Check first segment [0, p]</span>
                <span class="code-token-keyword">bool</span> valid = true;
                <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 1; i <= p; i++) {
                    <span class="code-token-keyword">if</span> (nums[i] <= nums[i-1]) {
                        valid = false;
                        <span class="code-token-keyword">break</span>;
                    }
                }
                <span class="code-token-keyword">if</span> (!valid) <span class="code-token-keyword">continue</span>;
                
                <span class="code-token-comment">// Check second segment [p, q]</span>
                <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = p+1; i <= q; i++) {
                    <span class="code-token-keyword">if</span> (nums[i] >= nums[i-1]) {
                        valid = false;
                        <span class="code-token-keyword">break</span>;
                    }
                }
                <span class="code-token-keyword">if</span> (!valid) <span class="code-token-keyword">continue</span>;
                
                <span class="code-token-comment">// Check third segment [q, n-1]</span>
                <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = q+1; i < n; i++) {
                    <span class="code-token-keyword">if</span> (nums[i] <= nums[i-1]) {
                        valid = false;
                        <span class="code-token-keyword">break</span>;
                    }
                }
                <span class="code-token-keyword">if</span> (valid) <span class="code-token-keyword">return</span> true;
            }
        }
        <span class="code-token-keyword">return</span> false;
    }
};</code></pre>
        </div>

        <!-- Java Code -->
        <div class="tab-content" id="java-brute-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">boolean</span> <span class="code-token-function">isTrionic</span>(<span class="code-token-keyword">int</span>[] nums) {
        <span class="code-token-keyword">int</span> n = nums.length;
        <span class="code-token-keyword">if</span> (n < 4) <span class="code-token-keyword">return</span> false;
        
        <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> p = 1; p <= n-3; p++) {
            <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> q = p+1; q <= n-2; q++) {
                <span class="code-token-comment">// Check first segment [0, p]</span>
                <span class="code-token-keyword">boolean</span> valid = true;
                <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = 1; i <= p; i++) {
                    <span class="code-token-keyword">if</span> (nums[i] <= nums[i-1]) {
                        valid = false;
                        <span class="code-token-keyword">break</span>;
                    }
                }
                <span class="code-token-keyword">if</span> (!valid) <span class="code-token-keyword">continue</span>;
                
                <span class="code-token-comment">// Check second segment [p, q]</span>
                <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = p+1; i <= q; i++) {
                    <span class="code-token-keyword">if</span> (nums[i] >= nums[i-1]) {
                        valid = false;
                        <span class="code-token-keyword">break</span>;
                    }
                }
                <span class="code-token-keyword">if</span> (!valid) <span class="code-token-keyword">continue</span>;
                
                <span class="code-token-comment">// Check third segment [q, n-1]</span>
                <span class="code-token-keyword">for</span> (<span class="code-token-keyword">int</span> i = q+1; i < n; i++) {
                    <span class="code-token-keyword">if</span> (nums[i] <= nums[i-1]) {
                        valid = false;
                        <span class="code-token-keyword">break</span>;
                    }
                }
                <span class="code-token-keyword">if</span> (valid) <span class="code-token-keyword">return</span> true;
            }
        }
        <span class="code-token-keyword">return</span> false;
    }
}</code></pre>
        </div>

        <!-- Python Code -->
        <div class="tab-content" id="python-brute-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">isTrionic</span>(self, nums: List[<span class="code-token-keyword">int</span>]) -> <span class="code-token-keyword">bool</span>:
        n = len(nums)
        <span class="code-token-keyword">if</span> n < 4:
            <span class="code-token-keyword">return</span> False
            
        <span class="code-token-keyword">for</span> p <span class="code-token-keyword">in</span> range(1, n-2):
            <span class="code-token-keyword">for</span> q <span class="code-token-keyword">in</span> range(p+1, n-1):
                valid = True
                
                <span class="code-token-comment"># Check first segment [0, p]</span>
                <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(1, p+1):
                    <span class="code-token-keyword">if</span> nums[i] <= nums[i-1]:
                        valid = False
                        <span class="code-token-keyword">break</span>
                <span class="code-token-keyword">if</span> <span class="code-token-keyword">not</span> valid:
                    <span class="code-token-keyword">continue</span>
                    
                <span class="code-token-comment"># Check second segment [p, q]</span>
                <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(p+1, q+1):
                    <span class="code-token-keyword">if</span> nums[i] >= nums[i-1]:
                        valid = False
                        <span class="code-token-keyword">break</span>
                <span class="code-token-keyword">if</span> <span class="code-token-keyword">not</span> valid:
                    <span class="code-token-keyword">continue</span>
                    
                <span class="code-token-comment"># Check third segment [q, n-1]</span>
                <span class="code-token-keyword">for</span> i <span class="code-token-keyword">in</span> range(q+1, n):
                    <span class="code-token-keyword">if</span> nums[i] <= nums[i-1]:
                        valid = False
                        <span class="code-token-keyword">break</span>
                <span class="code-token-keyword">if</span> valid:
                    <span class="code-token-keyword">return</span> True
                    
        <span class="code-token-keyword">return</span> False</code></pre>
        </div>
      </div>
      <div class="callout danger">
        <strong>Warning:</strong> This solution becomes inefficient for arrays near the maximum constraint size (n=100) due to its O(n³) complexity.
      </div>
    </div>

    <hr />

    <h2>Optimized Approach: Single Pass Through Array</h2>
    <p>This approach traverses the array once to find valid p and q indices:</p>
    
    <h3>Algorithm Steps</h3>
    <ol>
      <li>Start from index 0 and traverse while strictly increasing (find peak p)</li>
      <li>From p, traverse while strictly decreasing (find valley q)</li>
      <li>From q, traverse while strictly increasing to the end</li>
      <li>Verify that:
        <ul>
          <li>p and q are valid (0 &lt; p &lt; q &lt; n-1)</li>
          <li>The entire array is traversed</li>
        </ul>
      </li>
    </ol>
    
    <h3>Why This Works</h3>
    <p>The trionic array has a specific pattern: increase → decrease → increase. By traversing the array once, we can validate this pattern exists.</p>
    
    <h3>Complexity Analysis</h3>
    <table>
      <thead>
        <tr>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>O(n)</td>
          <td>O(1)</td>
        </tr>
      </tbody>
    </table>
    <p>This solution efficiently handles the maximum constraint (n=100) with a single pass through the array.</p>

    <div class="code-container">
      <div class="code-header">
        <span class="code-filename">Optimal Solution (Single Pass)</span>
        <button class="code-copy">Copy Code</button>
      </div>
      <div class="code-tabs">
        <div class="tab-buttons">
          <button class="tab-button active" data-tab="cpp-opt">C++</button>
          <button class="tab-button" data-tab="java-opt">Java</button>
          <button class="tab-button" data-tab="python-opt">Python</button>
        </div>

        <!-- C++ Code -->
        <div class="tab-content active" id="cpp-opt-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
<span class="code-token-keyword">public</span>:
    <span class="code-token-keyword">bool</span> <span class="code-token-function">isTrionic</span>(vector<<span class="code-token-keyword">int</span>>& nums) {
        <span class="code-token-keyword">int</span> n = nums.size();
        <span class="code-token-keyword">int</span> i = 0;

        <span class="code-token-comment">// Strictly increasing to peak p</span>
        <span class="code-token-keyword">while</span> (i+1 < n && nums[i] < nums[i+1]) {
            i++;
        }
        
        <span class="code-token-comment">// Check if we have valid p (must have increased at least once)</span>
        <span class="code-token-keyword">if</span> (i == 0 || i >= n-2) {
            <span class="code-token-keyword">return</span> false;
        }
        <span class="code-token-keyword">int</span> p = i;

        <span class="code-token-comment">// Strictly decreasing to valley q</span>
        <span class="code-token-keyword">while</span> (i+1 < n && nums[i] > nums[i+1]) {
            i++;
        }
        
        <span class="code-token-comment">// Check if we have valid q (must have decreased at least once)</span>
        <span class="code-token-keyword">if</span> (i == p || i >= n-1) {
            <span class="code-token-keyword">return</span> false;
        }
        <span class="code-token-keyword">int</span> q = i;

        <span class="code-token-comment">// Strictly increasing to the end</span>
        <span class="code-token-keyword">while</span> (i+1 < n && nums[i] < nums[i+1]) {
            i++;
        }
        
        <span class="code-token-comment">// Must reach the last element</span>
        <span class="code-token-keyword">return</span> i == n-1;
    }
};</code></pre>
        </div>

        <!-- Java Code -->
        <div class="tab-content" id="java-opt-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span> {
    <span class="code-token-keyword">public</span> <span class="code-token-keyword">boolean</span> <span class="code-token-function">isTrionic</span>(<span class="code-token-keyword">int</span>[] nums) {
        <span class="code-token-keyword">int</span> n = nums.length;
        <span class="code-token-keyword">int</span> i = 0;

        <span class="code-token-comment">// Strictly increasing to peak p</span>
        <span class="code-token-keyword">while</span> (i+1 < n && nums[i] < nums[i+1]) {
            i++;
        }
        
        <span class="code-token-comment">// Check valid p (must have increased at least once)</span>
        <span class="code-token-keyword">if</span> (i == 0 || i >= n-2) {
            <span class="code-token-keyword">return</span> false;
        }
        <span class="code-token-keyword">int</span> p = i;

        <span class="code-token-comment">// Strictly decreasing to valley q</span>
        <span class="code-token-keyword">while</span> (i+1 < n && nums[i] > nums[i+1]) {
            i++;
        }
        
        <span class="code-token-comment">// Check valid q (must have decreased at least once)</span>
        <span class="code-token-keyword">if</span> (i == p || i >= n-1) {
            <span class="code-token-keyword">return</span> false;
        }
        <span class="code-token-keyword">int</span> q = i;

        <span class="code-token-comment">// Strictly increasing to the end</span>
        <span class="code-token-keyword">while</span> (i+1 < n && nums[i] < nums[i+1]) {
            i++;
        }
        
        <span class="code-token-comment">// Must reach the last element</span>
        <span class="code-token-keyword">return</span> i == n-1;
    }
}</code></pre>
        </div>

        <!-- Python Code -->
        <div class="tab-content" id="python-opt-tab">
          <pre><code><span class="code-token-keyword">class</span> <span class="code-token-function">Solution</span>:
    <span class="code-token-keyword">def</span> <span class="code-token-function">isTrionic</span>(self, nums: List[<span class="code-token-keyword">int</span>]) -> <span class="code-token-keyword">bool</span>:
        n = len(nums)
        i = 0
        
        <span class="code-token-comment"># Strictly increasing to peak p</span>
        <span class="code-token-keyword">while</span> i+1 < n <span class="code-token-keyword">and</span> nums[i] < nums[i+1]:
            i += 1
            
        <span class="code-token-comment"># Check valid p (must have increased at least once)</span>
        <span class="code-token-keyword">if</span> i == 0 <span class="code-token-keyword">or</span> i >= n-2:
            <span class="code-token-keyword">return</span> False
        p = i
        
        <span class="code-token-comment"># Strictly decreasing to valley q</span>
        <span class="code-token-keyword">while</span> i+1 < n <span class="code-token-keyword">and</span> nums[i] > nums[i+1]:
            i += 1
            
        <span class="code-token-comment"># Check valid q (must have decreased at least once)</span>
        <span class="code-token-keyword">if</span> i == p <span class="code-token-keyword">or</span> i >= n-1:
            <span class="code-token-keyword">return</span> False
        q = i
        
        <span class="code-token-comment"># Strictly increasing to the end</span>
        <span class="code-token-keyword">while</span> i+1 < n <span class="code-token-keyword">and</span> nums[i] < nums[i+1]:
            i += 1
            
        <span class="code-token-comment"># Must reach the last element</span>
        <span class="code-token-keyword">return</span> i == n-1</code></pre>
        </div>
      </div>
      <div class="callout note">
        <strong>Implementation Note:</strong> This solution efficiently handles all cases in O(n) time by traversing the array once and validating the pattern as it goes.
      </div>
    </div>

    <hr />

    <h2>Edge Cases and Testing</h2>
    <h3>1. Minimum Length Array</h3>
    <pre><code>Input: [1,2,3] → Output: false
Explanation: Array has only 3 elements, cannot form three segments</code></pre>

    <h3>2. Constant Values</h3>
    <pre><code>Input: [5,5,5,5] → Output: false
Explanation: No strictly increasing or decreasing segments</code></pre>

    <h3>3. Multiple Peaks</h3>
    <pre><code>Input: [1,3,2,4,3] → Output: false
Explanation: Has two peaks but doesn't follow the required pattern</code></pre>

    <h3>4. Valid Complex Pattern</h3>
    <pre><code>Input: [1,2,5,4,3,2,1,2,3,4] → Output: true
Explanation: 
  p=2 (value 5), q=6 (value 1)
  [1,2,5] → increasing
  [5,4,3,2,1] → decreasing
  [1,2,3,4] → increasing</code></pre>

    <h3>5. Only Increasing</h3>
    <pre><code>Input: [1,2,3,4,5] → Output: false
Explanation: Never decreases so cannot form the middle segment</code></pre>

    <div class="callout danger">
      <strong>Warning:</strong> Always test with edge cases like small arrays, constant values, and arrays with multiple peaks/valleys.
    </div>

    <hr />

    <h2>Detailed Explanation of Optimal Approach</h2>
    <p>The optimal solution works by traversing the array once and verifying the required pattern as it goes. Here's a step-by-step breakdown:</p>
    
    <div class="grid-container">
      <div class="grid-item" style="animation: pulse 2s infinite;">1</div>
      <div class="grid-item" style="animation: pulse 2s infinite 0.2s;">2</div>
      <div class="grid-item" style="animation: pulse 2s infinite 0.4s;">3</div>
      <div class="grid-item" style="animation: pulse 2s infinite 0.6s;">4</div>
      <div class="grid-item" style="animation: pulse 2s infinite 0.8s;">5</div>
      <div class="grid-item" style="animation: pulse 2s infinite 1.0s;">6</div>
    </div>
    
    <ol>
      <li><strong>Initialization:</strong> Start at index 0</li>
      <li><strong>First Segment (Increasing):</strong> Move forward as long as each element is greater than the previous</li>
      <li><strong>Peak Validation:</strong> After the first segment, we must have moved at least one step (i > 0) and have at least two elements remaining (i < n-2)</li>
      <li><strong>Second Segment (Decreasing):</strong> Continue moving forward as long as each element is less than the previous</li>
      <li><strong>Valley Validation:</strong> After the second segment, we must have moved at least one step (i > p) and have at least one element remaining (i < n-1)</li>
      <li><strong>Third Segment (Increasing):</strong> Continue moving forward as long as each element is greater than the previous</li>
      <li><strong>Final Validation:</strong> We must reach the last element of the array</li>
    </ol>
    
    <p>This approach efficiently verifies the trionic pattern in O(n) time with O(1) space by leveraging the sequential nature of the required pattern. The key insight is that the trionic array has a single peak followed by a single valley, after which it increases again.</p>
    
    <div class="callout tip">
      <strong>Why it works:</strong> The solution directly follows the problem's requirements - it finds the first peak (p), then the first valley after that peak (q), and ensures the rest of the array increases. By doing this in a single pass, it achieves optimal efficiency.
    </div>

    <hr />

    <h2>Related Topics Explained</h2>

    <h3>Array Traversal</h3>
    <p>Array traversal is fundamental to solving this problem:</p>
    <ul>
      <li>We examine elements sequentially from start to end</li>
      <li>At each step, we compare the current element with the next</li>
      <li>Different traversal patterns (single pass, nested loops) have significant performance implications</li>
    </ul>

    <h3>Pattern Recognition</h3>
    <p>This problem is essentially about recognizing a specific pattern in data:</p>
    <ul>
      <li>The trionic pattern has three distinct phases: up, down, up</li>
      <li>Real-world applications include analyzing stock prices, signal processing, and topographic data</li>
      <li>Pattern recognition problems often have efficient solutions when the pattern is well-defined</li>
    </ul>

    <h3>Algorithm Optimization</h3>
    <p>Moving from O(n³) to O(n) demonstrates important optimization principles:</p>
    <ul>
      <li>Recognize that brute force checking is inefficient</li>
      <li>Look for patterns that can be verified sequentially</li>
      <li>Leverage constraints to eliminate unnecessary checks</li>
    </ul>

    <div class="callout">
      <strong>Final Insight:</strong> The trionic array problem is an excellent example of how understanding the problem's inherent pattern can lead to an optimal solution. While the brute force approach is straightforward, the single-pass solution is both elegant and efficient.
    </div>
    
    <hr />
    
    <div class="faq-section">
      <h2>Frequently Asked Questions</h2>
      
      <details>
        <summary>What is the minimum array length for a trionic array?</summary>
        <p>The minimum length is 4 elements. This is required to have at least one element in each segment while satisfying 0 &lt; p &lt; q &lt; n-1. For example: [1,2,1,2]</p>
      </details>
      
      <details>
        <summary>Can a trionic array have duplicate values?</summary>
        <p>No, the problem requires <strong>strictly</strong> increasing and decreasing segments. This means adjacent elements must be strictly greater or smaller, not equal.</p>
      </details>
      
      <details>
        <summary>Is the peak (p) always the maximum element?</summary>
        <p>Yes, the peak p will always be the maximum element in the array. The valley q will be the minimum element in the middle segment, but may not be the global minimum.</p>
      </details>
      
      <details>
        <summary>Can the array have multiple peaks and valleys?</summary>
        <p>No, the trionic array pattern specifically requires one peak (p) and one valley (q). Arrays with multiple peaks/valleys don't satisfy the problem's requirements.</p>
      </details>
      
      <details>
        <summary>How does the optimal solution handle invalid patterns early?</summary>
        <p>By checking conditions after each segment. If we don't move during a segment (i remains the same), we immediately return false. This provides early termination for invalid arrays.</p>
      </details>
    </div>
  </main>

  <div id="footer"></div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Tab functionality
      document.querySelectorAll('.code-tabs').forEach(container => {
        const tabButtons = container.querySelectorAll('.tab-button');
        const tabContents = container.querySelectorAll('.tab-content');
        
        // Initialize first tab
        if (!container.querySelector('.tab-button.active')) {
          tabButtons[0]?.classList.add('active');
          tabContents[0]?.classList.add('active');
        }
        
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            const tabName = button.getAttribute('data-tab');
            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            button.classList.add('active');
            container.querySelector(`#${tabName}-tab`).classList.add('active');
          });
        });
      });
      
      // Copy button functionality
      document.querySelectorAll('.code-copy').forEach(button => {
        button.addEventListener('click', () => {
          const activeTab = button.closest('.code-container').querySelector('.tab-content.active');
          const code = activeTab.querySelector('code').innerText;
          navigator.clipboard.writeText(code).then(() => {
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            setTimeout(() => button.textContent = originalText, 2000);
          });
        });
      });

      // Load header and footer
      fetch("../components/header.html")
        .then((response) => response.text())
        .then((data) => {
          document.getElementById("header").innerHTML = data;
        });

      fetch("../components/footer.html")
        .then((response) => response.text())
        .then((data) => {
          document.getElementById("footer").innerHTML = data;
        });
    });
  </script>
</body>
</html>